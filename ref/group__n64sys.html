<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libdragon: N64 System Interface</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">libdragon
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">N64 System Interface<div class="ingroups"><a class="el" href="group__libdragon.html">libdragon</a> &raquo; <a class="el" href="group__lowlevel.html">Low Level Hardware Interfaces</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>N64 bootup and cache interfaces.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="files" name="files"></a>
Files</h2></td></tr>
<tr class="memitem:n64sys_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="n64sys_8c.html">n64sys.c</a></td></tr>
<tr class="memdesc:n64sys_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">N64 System Interface. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:cop0_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cop0_8h.html">cop0.h</a></td></tr>
<tr class="memdesc:cop0_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">N64 COP0 Interface. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:cop1_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cop1_8h.html">cop1.h</a></td></tr>
<tr class="memdesc:cop1_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">N64 COP1 Interface. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:n64sys_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="n64sys_8h.html">n64sys.h</a></td></tr>
<tr class="memdesc:n64sys_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">N64 System Interface. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gac69e8a7b3752d227238ff76b56b3fa17"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__n64sys.html#gac69e8a7b3752d227238ff76b56b3fa17">cache_op</a>(op,  linesize)</td></tr>
<tr class="memdesc:gac69e8a7b3752d227238ff76b56b3fa17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro to perform cache refresh operations.  <a href="group__n64sys.html#gac69e8a7b3752d227238ff76b56b3fa17">More...</a><br /></td></tr>
<tr class="separator:gac69e8a7b3752d227238ff76b56b3fa17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16a9cb3b1d15189bd1c21327cd77ca1f"><td class="memItemLeft" align="right" valign="top"><a id="ga16a9cb3b1d15189bd1c21327cd77ca1f" name="ga16a9cb3b1d15189bd1c21327cd77ca1f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TV_TYPE_LOC</b>&#160;&#160;&#160;0x80000300</td></tr>
<tr class="memdesc:ga16a9cb3b1d15189bd1c21327cd77ca1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory location to read which determines the TV type. <br /></td></tr>
<tr class="separator:ga16a9cb3b1d15189bd1c21327cd77ca1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06cc6d925caa4db67e81281eef124d28"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__n64sys.html#ga06cc6d925caa4db67e81281eef124d28">C0_COUNT</a>()</td></tr>
<tr class="memdesc:ga06cc6d925caa4db67e81281eef124d28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the COP0 Count register (see also TICKS_READ).  <a href="group__n64sys.html#ga06cc6d925caa4db67e81281eef124d28">More...</a><br /></td></tr>
<tr class="separator:ga06cc6d925caa4db67e81281eef124d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69b664bbbc0e14604ecfd09623008fd6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__n64sys.html#ga69b664bbbc0e14604ecfd09623008fd6">C0_WRITE_COUNT</a>(x)</td></tr>
<tr class="memdesc:ga69b664bbbc0e14604ecfd09623008fd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the COP0 Count register.  <a href="group__n64sys.html#ga69b664bbbc0e14604ecfd09623008fd6">More...</a><br /></td></tr>
<tr class="separator:ga69b664bbbc0e14604ecfd09623008fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ec3fa2068670095b1c6a07ff07a456b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__n64sys.html#ga3ec3fa2068670095b1c6a07ff07a456b">C0_COMPARE</a>()</td></tr>
<tr class="memdesc:ga3ec3fa2068670095b1c6a07ff07a456b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the COP0 Compare register.  <a href="group__n64sys.html#ga3ec3fa2068670095b1c6a07ff07a456b">More...</a><br /></td></tr>
<tr class="separator:ga3ec3fa2068670095b1c6a07ff07a456b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga666712469205d6847d0120a7ac3e856d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__n64sys.html#ga666712469205d6847d0120a7ac3e856d">C0_WRITE_COMPARE</a>(x)</td></tr>
<tr class="memdesc:ga666712469205d6847d0120a7ac3e856d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the COP0 Compare register.  <a href="group__n64sys.html#ga666712469205d6847d0120a7ac3e856d">More...</a><br /></td></tr>
<tr class="separator:ga666712469205d6847d0120a7ac3e856d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeeaf9cf4736be55054b718e5577618fc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__n64sys.html#gaeeaf9cf4736be55054b718e5577618fc">C0_STATUS</a>()</td></tr>
<tr class="memdesc:gaeeaf9cf4736be55054b718e5577618fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the COP0 Status register.  <a href="group__n64sys.html#gaeeaf9cf4736be55054b718e5577618fc">More...</a><br /></td></tr>
<tr class="separator:gaeeaf9cf4736be55054b718e5577618fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18dd4fdf1ca79c2976239698b8abdaac"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__n64sys.html#ga18dd4fdf1ca79c2976239698b8abdaac">C0_WRITE_STATUS</a>(x)</td></tr>
<tr class="memdesc:ga18dd4fdf1ca79c2976239698b8abdaac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the COP0 Status register.  <a href="group__n64sys.html#ga18dd4fdf1ca79c2976239698b8abdaac">More...</a><br /></td></tr>
<tr class="separator:ga18dd4fdf1ca79c2976239698b8abdaac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3207bfb3c7309dc93467172a04edcd67"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__n64sys.html#ga3207bfb3c7309dc93467172a04edcd67">C0_CAUSE</a>()</td></tr>
<tr class="memdesc:ga3207bfb3c7309dc93467172a04edcd67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the COP0 register $13 (Cause Register)  <a href="group__n64sys.html#ga3207bfb3c7309dc93467172a04edcd67">More...</a><br /></td></tr>
<tr class="separator:ga3207bfb3c7309dc93467172a04edcd67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3ce6c31c752f1764961c80e054b2d40"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__n64sys.html#gaa3ce6c31c752f1764961c80e054b2d40">C0_WRITE_CAUSE</a>(x)</td></tr>
<tr class="memdesc:gaa3ce6c31c752f1764961c80e054b2d40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the COP0 register $13 (Cause register)  <a href="group__n64sys.html#gaa3ce6c31c752f1764961c80e054b2d40">More...</a><br /></td></tr>
<tr class="separator:gaa3ce6c31c752f1764961c80e054b2d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c0eaba2123f76f15834eab8e2a40e8c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__n64sys.html#ga2c0eaba2123f76f15834eab8e2a40e8c">C0_BADVADDR</a>()</td></tr>
<tr class="memdesc:ga2c0eaba2123f76f15834eab8e2a40e8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the COP0 register $8 (BadVAddr)  <a href="group__n64sys.html#ga2c0eaba2123f76f15834eab8e2a40e8c">More...</a><br /></td></tr>
<tr class="separator:ga2c0eaba2123f76f15834eab8e2a40e8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7422a36ebf589991fa8408afdb100d5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__n64sys.html#gaa7422a36ebf589991fa8408afdb100d5">C0_EPC</a>()</td></tr>
<tr class="memdesc:gaa7422a36ebf589991fa8408afdb100d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the COP0 register $14 (EPC)  <a href="group__n64sys.html#gaa7422a36ebf589991fa8408afdb100d5">More...</a><br /></td></tr>
<tr class="separator:gaa7422a36ebf589991fa8408afdb100d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b28c8fdc6397b49616a494a69b7ea6d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__n64sys.html#ga8b28c8fdc6397b49616a494a69b7ea6d">C0_INDEX</a>()</td></tr>
<tr class="memdesc:ga8b28c8fdc6397b49616a494a69b7ea6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the COP0 INDEX register.  <a href="group__n64sys.html#ga8b28c8fdc6397b49616a494a69b7ea6d">More...</a><br /></td></tr>
<tr class="separator:ga8b28c8fdc6397b49616a494a69b7ea6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03738b353bc8fb592d1de0e04deab548"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__n64sys.html#ga03738b353bc8fb592d1de0e04deab548">C0_WRITE_INDEX</a>(x)&#160;&#160;&#160;asm volatile(&quot;mtc0 %0,$0; nop; nop&quot;::&quot;r&quot;(x))</td></tr>
<tr class="memdesc:ga03738b353bc8fb592d1de0e04deab548"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the COP0 INDEX register.  <a href="group__n64sys.html#ga03738b353bc8fb592d1de0e04deab548">More...</a><br /></td></tr>
<tr class="separator:ga03738b353bc8fb592d1de0e04deab548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga019789477bcd2c33e7de911f61f928b3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__n64sys.html#ga019789477bcd2c33e7de911f61f928b3">C0_ENTRYHI</a>()</td></tr>
<tr class="memdesc:ga019789477bcd2c33e7de911f61f928b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the COP0 ENTRYHI register.  <a href="group__n64sys.html#ga019789477bcd2c33e7de911f61f928b3">More...</a><br /></td></tr>
<tr class="separator:ga019789477bcd2c33e7de911f61f928b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04b2274990f863599b9c9aba56d20c24"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__n64sys.html#ga04b2274990f863599b9c9aba56d20c24">C0_WRITE_ENTRYHI</a>(x)&#160;&#160;&#160;asm volatile(&quot;mtc0 %0,$10; nop; nop&quot;::&quot;r&quot;(x))</td></tr>
<tr class="memdesc:ga04b2274990f863599b9c9aba56d20c24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the COP0 ENTRYHI register.  <a href="group__n64sys.html#ga04b2274990f863599b9c9aba56d20c24">More...</a><br /></td></tr>
<tr class="separator:ga04b2274990f863599b9c9aba56d20c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga161d0e63d1b4e2749984e9e548a993cb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__n64sys.html#ga161d0e63d1b4e2749984e9e548a993cb">C0_ENTRYLO0</a>()</td></tr>
<tr class="memdesc:ga161d0e63d1b4e2749984e9e548a993cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the COP0 ENTRYLO0 register.  <a href="group__n64sys.html#ga161d0e63d1b4e2749984e9e548a993cb">More...</a><br /></td></tr>
<tr class="separator:ga161d0e63d1b4e2749984e9e548a993cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0400812af6bd1c9f594727092f22afb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__n64sys.html#gaf0400812af6bd1c9f594727092f22afb">C0_WRITE_ENTRYLO0</a>(x)&#160;&#160;&#160;asm volatile(&quot;mtc0 %0,$2; nop; nop&quot;::&quot;r&quot;(x))</td></tr>
<tr class="memdesc:gaf0400812af6bd1c9f594727092f22afb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the COP0 ENTRYLO0 register.  <a href="group__n64sys.html#gaf0400812af6bd1c9f594727092f22afb">More...</a><br /></td></tr>
<tr class="separator:gaf0400812af6bd1c9f594727092f22afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ee011d11bced21664d2c1cead5fb539"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__n64sys.html#ga5ee011d11bced21664d2c1cead5fb539">C0_ENTRYLO1</a>()</td></tr>
<tr class="memdesc:ga5ee011d11bced21664d2c1cead5fb539"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the COP0 ENTRYLO1 register.  <a href="group__n64sys.html#ga5ee011d11bced21664d2c1cead5fb539">More...</a><br /></td></tr>
<tr class="separator:ga5ee011d11bced21664d2c1cead5fb539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21d4746ec6141ca47e79af8b3567cd21"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__n64sys.html#ga21d4746ec6141ca47e79af8b3567cd21">C0_WRITE_ENTRYLO1</a>(x)&#160;&#160;&#160;asm volatile(&quot;mtc0 %0,$3; nop; nop&quot;::&quot;r&quot;(x))</td></tr>
<tr class="memdesc:ga21d4746ec6141ca47e79af8b3567cd21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the COP0 ENTRYLO1 register.  <a href="group__n64sys.html#ga21d4746ec6141ca47e79af8b3567cd21">More...</a><br /></td></tr>
<tr class="separator:ga21d4746ec6141ca47e79af8b3567cd21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b305a5519adcf34759a3776854cacfd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__n64sys.html#ga0b305a5519adcf34759a3776854cacfd">C0_PAGEMASK</a>()</td></tr>
<tr class="memdesc:ga0b305a5519adcf34759a3776854cacfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the COP0 PAGEMASK register.  <a href="group__n64sys.html#ga0b305a5519adcf34759a3776854cacfd">More...</a><br /></td></tr>
<tr class="separator:ga0b305a5519adcf34759a3776854cacfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea93ec852849f2ffd39dd8e8f20a33fc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__n64sys.html#gaea93ec852849f2ffd39dd8e8f20a33fc">C0_WRITE_PAGEMASK</a>(x)&#160;&#160;&#160;asm volatile(&quot;mtc0 %0,$5; nop; nop&quot;::&quot;r&quot;(x))</td></tr>
<tr class="memdesc:gaea93ec852849f2ffd39dd8e8f20a33fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the COP0 PAGEMASK register.  <a href="group__n64sys.html#gaea93ec852849f2ffd39dd8e8f20a33fc">More...</a><br /></td></tr>
<tr class="separator:gaea93ec852849f2ffd39dd8e8f20a33fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fa34561986e5c2ba44159a362f65abb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__n64sys.html#ga5fa34561986e5c2ba44159a362f65abb">C0_WIRED</a>()</td></tr>
<tr class="memdesc:ga5fa34561986e5c2ba44159a362f65abb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the COP0 WIRED register.  <a href="group__n64sys.html#ga5fa34561986e5c2ba44159a362f65abb">More...</a><br /></td></tr>
<tr class="separator:ga5fa34561986e5c2ba44159a362f65abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace54d6bc9240a2ca470d2312fd3bd5f3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__n64sys.html#gace54d6bc9240a2ca470d2312fd3bd5f3">C0_WRITE_WIRED</a>(x)&#160;&#160;&#160;asm volatile(&quot;mtc0 %0,$6; nop; nop&quot;::&quot;r&quot;(x))</td></tr>
<tr class="memdesc:gace54d6bc9240a2ca470d2312fd3bd5f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the COP0 WIRED register.  <a href="group__n64sys.html#gace54d6bc9240a2ca470d2312fd3bd5f3">More...</a><br /></td></tr>
<tr class="separator:gace54d6bc9240a2ca470d2312fd3bd5f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29d2ddc289dea210310297840b3a3f3f"><td class="memItemLeft" align="right" valign="top"><a id="ga29d2ddc289dea210310297840b3a3f3f" name="ga29d2ddc289dea210310297840b3a3f3f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>C0_STATUS_IE</b>&#160;&#160;&#160;0x00000001</td></tr>
<tr class="memdesc:ga29d2ddc289dea210310297840b3a3f3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Status: interrupt enable. <br /></td></tr>
<tr class="separator:ga29d2ddc289dea210310297840b3a3f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabaa508f72aaafde765595f809bf3e921"><td class="memItemLeft" align="right" valign="top"><a id="gabaa508f72aaafde765595f809bf3e921" name="gabaa508f72aaafde765595f809bf3e921"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>C0_STATUS_EXL</b>&#160;&#160;&#160;0x00000002</td></tr>
<tr class="memdesc:gabaa508f72aaafde765595f809bf3e921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Status: within exception. <br /></td></tr>
<tr class="separator:gabaa508f72aaafde765595f809bf3e921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81700617afd959418764c1fcb643b033"><td class="memItemLeft" align="right" valign="top"><a id="ga81700617afd959418764c1fcb643b033" name="ga81700617afd959418764c1fcb643b033"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>C0_STATUS_ERL</b>&#160;&#160;&#160;0x00000004</td></tr>
<tr class="memdesc:ga81700617afd959418764c1fcb643b033"><td class="mdescLeft">&#160;</td><td class="mdescRight">Status: within error. <br /></td></tr>
<tr class="separator:ga81700617afd959418764c1fcb643b033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5b5beedec5d8fb382744877c760c343"><td class="memItemLeft" align="right" valign="top"><a id="gae5b5beedec5d8fb382744877c760c343" name="gae5b5beedec5d8fb382744877c760c343"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>C0_CAUSE_BD</b>&#160;&#160;&#160;0x80000000</td></tr>
<tr class="memdesc:gae5b5beedec5d8fb382744877c760c343"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cause: exception triggered in delay slot. <br /></td></tr>
<tr class="separator:gae5b5beedec5d8fb382744877c760c343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga312cb5b3b8a176e307f05f7462b0b195"><td class="memItemLeft" align="right" valign="top"><a id="ga312cb5b3b8a176e307f05f7462b0b195" name="ga312cb5b3b8a176e307f05f7462b0b195"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>C0_CAUSE_CE</b>&#160;&#160;&#160;0x30000000</td></tr>
<tr class="memdesc:ga312cb5b3b8a176e307f05f7462b0b195"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cause: coprocessor exception. <br /></td></tr>
<tr class="separator:ga312cb5b3b8a176e307f05f7462b0b195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2becb1f066e5658e7324db3d7704ff54"><td class="memItemLeft" align="right" valign="top"><a id="ga2becb1f066e5658e7324db3d7704ff54" name="ga2becb1f066e5658e7324db3d7704ff54"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>C0_CAUSE_EXC_CODE</b>&#160;&#160;&#160;0x0000007C</td></tr>
<tr class="memdesc:ga2becb1f066e5658e7324db3d7704ff54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cause: exception code. <br /></td></tr>
<tr class="separator:ga2becb1f066e5658e7324db3d7704ff54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafde0b9dffa850e11cc25e5fb1099cb96"><td class="memItemLeft" align="right" valign="top"><a id="gafde0b9dffa850e11cc25e5fb1099cb96" name="gafde0b9dffa850e11cc25e5fb1099cb96"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>C0_INTERRUPT_0</b>&#160;&#160;&#160;0x00000100</td></tr>
<tr class="memdesc:gafde0b9dffa850e11cc25e5fb1099cb96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Status/Cause: HW interrupt 0. <br /></td></tr>
<tr class="separator:gafde0b9dffa850e11cc25e5fb1099cb96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadea4f59bcf94b82ab19580e8f283db71"><td class="memItemLeft" align="right" valign="top"><a id="gadea4f59bcf94b82ab19580e8f283db71" name="gadea4f59bcf94b82ab19580e8f283db71"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>C0_INTERRUPT_1</b>&#160;&#160;&#160;0x00000200</td></tr>
<tr class="memdesc:gadea4f59bcf94b82ab19580e8f283db71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Status/Cause: HW interrupt 1. <br /></td></tr>
<tr class="separator:gadea4f59bcf94b82ab19580e8f283db71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8eb051946a61e6fd81e66f0f33028dd5"><td class="memItemLeft" align="right" valign="top"><a id="ga8eb051946a61e6fd81e66f0f33028dd5" name="ga8eb051946a61e6fd81e66f0f33028dd5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>C0_INTERRUPT_2</b>&#160;&#160;&#160;0x00000400</td></tr>
<tr class="memdesc:ga8eb051946a61e6fd81e66f0f33028dd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Status/Cause: HW interrupt 2 (RCP) <br /></td></tr>
<tr class="separator:ga8eb051946a61e6fd81e66f0f33028dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc9e6ee8e8c74217e5ea9e84aac18044"><td class="memItemLeft" align="right" valign="top"><a id="gadc9e6ee8e8c74217e5ea9e84aac18044" name="gadc9e6ee8e8c74217e5ea9e84aac18044"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>C0_INTERRUPT_3</b>&#160;&#160;&#160;0x00000800</td></tr>
<tr class="memdesc:gadc9e6ee8e8c74217e5ea9e84aac18044"><td class="mdescLeft">&#160;</td><td class="mdescRight">Status/Cause: HW interrupt 3. <br /></td></tr>
<tr class="separator:gadc9e6ee8e8c74217e5ea9e84aac18044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0b0012ee5e6fedb3813d3cb715c568a"><td class="memItemLeft" align="right" valign="top"><a id="gaa0b0012ee5e6fedb3813d3cb715c568a" name="gaa0b0012ee5e6fedb3813d3cb715c568a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>C0_INTERRUPT_4</b>&#160;&#160;&#160;0x00001000</td></tr>
<tr class="memdesc:gaa0b0012ee5e6fedb3813d3cb715c568a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Status/Cause: HW interrupt 4 (PRENMI) <br /></td></tr>
<tr class="separator:gaa0b0012ee5e6fedb3813d3cb715c568a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga189dbc53d5d762572ab98074c72628de"><td class="memItemLeft" align="right" valign="top"><a id="ga189dbc53d5d762572ab98074c72628de" name="ga189dbc53d5d762572ab98074c72628de"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>C0_INTERRUPT_5</b>&#160;&#160;&#160;0x00002000</td></tr>
<tr class="memdesc:ga189dbc53d5d762572ab98074c72628de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Status/Cause: HW interrupt 5. <br /></td></tr>
<tr class="separator:ga189dbc53d5d762572ab98074c72628de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf6d36e294d3f40d3b26359c3d75e1d2"><td class="memItemLeft" align="right" valign="top"><a id="gadf6d36e294d3f40d3b26359c3d75e1d2" name="gadf6d36e294d3f40d3b26359c3d75e1d2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>C0_INTERRUPT_6</b>&#160;&#160;&#160;0x00004000</td></tr>
<tr class="memdesc:gadf6d36e294d3f40d3b26359c3d75e1d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Status/Cause: HW interrupt 6. <br /></td></tr>
<tr class="separator:gadf6d36e294d3f40d3b26359c3d75e1d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga355848e5bf2a8f80122aba76f5701d2f"><td class="memItemLeft" align="right" valign="top"><a id="ga355848e5bf2a8f80122aba76f5701d2f" name="ga355848e5bf2a8f80122aba76f5701d2f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>C0_INTERRUPT_7</b>&#160;&#160;&#160;0x00008000</td></tr>
<tr class="memdesc:ga355848e5bf2a8f80122aba76f5701d2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Status/Cause: HW interrupt 7 (Timer) <br /></td></tr>
<tr class="separator:ga355848e5bf2a8f80122aba76f5701d2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga704100449656c8a2fbf27f4834d5746b"><td class="memItemLeft" align="right" valign="top"><a id="ga704100449656c8a2fbf27f4834d5746b" name="ga704100449656c8a2fbf27f4834d5746b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>C0_INTERRUPT_RCP</b>&#160;&#160;&#160;<a class="el" href="group__n64sys.html#ga8eb051946a61e6fd81e66f0f33028dd5">C0_INTERRUPT_2</a></td></tr>
<tr class="memdesc:ga704100449656c8a2fbf27f4834d5746b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Status/Cause: HW interrupt 2 (RCP) <br /></td></tr>
<tr class="separator:ga704100449656c8a2fbf27f4834d5746b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaface18baac16e7e91a2132bd34b3d681"><td class="memItemLeft" align="right" valign="top"><a id="gaface18baac16e7e91a2132bd34b3d681" name="gaface18baac16e7e91a2132bd34b3d681"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>C0_INTERRUPT_PRENMI</b>&#160;&#160;&#160;<a class="el" href="group__n64sys.html#gaa0b0012ee5e6fedb3813d3cb715c568a">C0_INTERRUPT_4</a></td></tr>
<tr class="memdesc:gaface18baac16e7e91a2132bd34b3d681"><td class="mdescLeft">&#160;</td><td class="mdescRight">Status/Cause: HW interrupt 4 (PRENMI) <br /></td></tr>
<tr class="separator:gaface18baac16e7e91a2132bd34b3d681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65deb85bae05eae40c9b908d8d0a14b2"><td class="memItemLeft" align="right" valign="top"><a id="ga65deb85bae05eae40c9b908d8d0a14b2" name="ga65deb85bae05eae40c9b908d8d0a14b2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>C0_INTERRUPT_TIMER</b>&#160;&#160;&#160;<a class="el" href="group__n64sys.html#ga355848e5bf2a8f80122aba76f5701d2f">C0_INTERRUPT_7</a></td></tr>
<tr class="memdesc:ga65deb85bae05eae40c9b908d8d0a14b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Status/Cause: HW interrupt 7 (Timer) <br /></td></tr>
<tr class="separator:ga65deb85bae05eae40c9b908d8d0a14b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0ee128daa09f4992787f3d9a02130da"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__n64sys.html#gab0ee128daa09f4992787f3d9a02130da">C0_GET_CAUSE_CE</a>(cr)&#160;&#160;&#160;(((cr) &amp; <a class="el" href="group__n64sys.html#ga312cb5b3b8a176e307f05f7462b0b195">C0_CAUSE_CE</a>) &gt;&gt; 28)</td></tr>
<tr class="memdesc:gab0ee128daa09f4992787f3d9a02130da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the CE value from the COP0 status register.  <a href="group__n64sys.html#gab0ee128daa09f4992787f3d9a02130da">More...</a><br /></td></tr>
<tr class="separator:gab0ee128daa09f4992787f3d9a02130da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d7694469905182150475bac6179be6d"><td class="memItemLeft" align="right" valign="top"><a id="ga2d7694469905182150475bac6179be6d" name="ga2d7694469905182150475bac6179be6d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>C0_GET_CAUSE_EXC_CODE</b>(sr)&#160;&#160;&#160;(((sr) &amp; <a class="el" href="group__n64sys.html#ga2becb1f066e5658e7324db3d7704ff54">C0_CAUSE_EXC_CODE</a>) &gt;&gt; 2)</td></tr>
<tr class="memdesc:ga2d7694469905182150475bac6179be6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the exception code value from the COP0 status register value. <br /></td></tr>
<tr class="separator:ga2d7694469905182150475bac6179be6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa623a51d6be58180e69da3991241c94e"><td class="memItemLeft" align="right" valign="top"><a id="gaa623a51d6be58180e69da3991241c94e" name="gaa623a51d6be58180e69da3991241c94e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>C0_ENTRYLO_GLOBAL</b>&#160;&#160;&#160;(1&lt;&lt;0)</td></tr>
<tr class="memdesc:gaa623a51d6be58180e69da3991241c94e"><td class="mdescLeft">&#160;</td><td class="mdescRight">ENTRYLO: mapping is global (all ASIDs) <br /></td></tr>
<tr class="separator:gaa623a51d6be58180e69da3991241c94e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22b87e58967eab3082131b8a9ab06e73"><td class="memItemLeft" align="right" valign="top"><a id="ga22b87e58967eab3082131b8a9ab06e73" name="ga22b87e58967eab3082131b8a9ab06e73"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>C0_ENTRYLO_VALID</b>&#160;&#160;&#160;(1&lt;&lt;1)</td></tr>
<tr class="memdesc:ga22b87e58967eab3082131b8a9ab06e73"><td class="mdescLeft">&#160;</td><td class="mdescRight">ENTRYLO: mapping is active (not disabled) <br /></td></tr>
<tr class="separator:ga22b87e58967eab3082131b8a9ab06e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab291285b91c8b9f5946e5f039032e56d"><td class="memItemLeft" align="right" valign="top"><a id="gab291285b91c8b9f5946e5f039032e56d" name="gab291285b91c8b9f5946e5f039032e56d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>C0_ENTRYLO_DIRTY</b>&#160;&#160;&#160;(1&lt;&lt;2)</td></tr>
<tr class="memdesc:gab291285b91c8b9f5946e5f039032e56d"><td class="mdescLeft">&#160;</td><td class="mdescRight">ENTRYLO: mapping is writable. <br /></td></tr>
<tr class="separator:gab291285b91c8b9f5946e5f039032e56d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13d30b736684b9e2d02de76dc50d8ac0"><td class="memItemLeft" align="right" valign="top"><a id="ga13d30b736684b9e2d02de76dc50d8ac0" name="ga13d30b736684b9e2d02de76dc50d8ac0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>C0_INDEX_PROBE_FAILED</b>&#160;&#160;&#160;(1&lt;&lt;31)</td></tr>
<tr class="memdesc:ga13d30b736684b9e2d02de76dc50d8ac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">INDEX: set when a TLBP probe failed to find a match. <br /></td></tr>
<tr class="separator:ga13d30b736684b9e2d02de76dc50d8ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c9067a58f6b9b4c3d89d3ec123de5ab"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__n64sys.html#ga0c9067a58f6b9b4c3d89d3ec123de5ab">C0_TLBWI</a>()&#160;&#160;&#160;asm volatile(&quot;tlbwi; nop; nop; nop; nop&quot;)</td></tr>
<tr class="memdesc:ga0c9067a58f6b9b4c3d89d3ec123de5ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">COP0 TLBWI opcode.  <a href="group__n64sys.html#ga0c9067a58f6b9b4c3d89d3ec123de5ab">More...</a><br /></td></tr>
<tr class="separator:ga0c9067a58f6b9b4c3d89d3ec123de5ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9064781426b89fb32d4acd176604010d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__n64sys.html#ga9064781426b89fb32d4acd176604010d">C0_TLBWR</a>()&#160;&#160;&#160;asm volatile(&quot;tlbwr; nop; nop; nop; nop&quot;)</td></tr>
<tr class="memdesc:ga9064781426b89fb32d4acd176604010d"><td class="mdescLeft">&#160;</td><td class="mdescRight">COP0 TLBWR opcode.  <a href="group__n64sys.html#ga9064781426b89fb32d4acd176604010d">More...</a><br /></td></tr>
<tr class="separator:ga9064781426b89fb32d4acd176604010d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb44eff79082cf67bcad321457adacb3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__n64sys.html#gabb44eff79082cf67bcad321457adacb3">C0_TLBR</a>()&#160;&#160;&#160;asm volatile(&quot;tlbr; nop; nop; nop; nop&quot;)</td></tr>
<tr class="memdesc:gabb44eff79082cf67bcad321457adacb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">COP0 TLBR opcode.  <a href="group__n64sys.html#gabb44eff79082cf67bcad321457adacb3">More...</a><br /></td></tr>
<tr class="separator:gabb44eff79082cf67bcad321457adacb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba427de075f56d64d19af61b38821ae3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__n64sys.html#gaba427de075f56d64d19af61b38821ae3">C0_TLBP</a>()&#160;&#160;&#160;asm volatile(&quot;tlbp; nop; nop; nop; nop&quot;)</td></tr>
<tr class="memdesc:gaba427de075f56d64d19af61b38821ae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">COP0 TLBP opcode.  <a href="group__n64sys.html#gaba427de075f56d64d19af61b38821ae3">More...</a><br /></td></tr>
<tr class="separator:gaba427de075f56d64d19af61b38821ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga150bd8366de1ab784d8a5a67c759fe86"><td class="memItemLeft" align="right" valign="top"><a id="ga150bd8366de1ab784d8a5a67c759fe86" name="ga150bd8366de1ab784d8a5a67c759fe86"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>C1_FLAG_INEXACT_OP</b>&#160;&#160;&#160;0x00000004</td></tr>
<tr class="memdesc:ga150bd8366de1ab784d8a5a67c759fe86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag recording inexact operation. <br /></td></tr>
<tr class="separator:ga150bd8366de1ab784d8a5a67c759fe86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga073dd1c7226b9777125c27677dd6c99f"><td class="memItemLeft" align="right" valign="top"><a id="ga073dd1c7226b9777125c27677dd6c99f" name="ga073dd1c7226b9777125c27677dd6c99f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>C1_FLAG_UNDERFLOW</b>&#160;&#160;&#160;0x00000008</td></tr>
<tr class="memdesc:ga073dd1c7226b9777125c27677dd6c99f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag recording underflow. <br /></td></tr>
<tr class="separator:ga073dd1c7226b9777125c27677dd6c99f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1a388362f5a99bfadee5fd091d7db0a"><td class="memItemLeft" align="right" valign="top"><a id="gaf1a388362f5a99bfadee5fd091d7db0a" name="gaf1a388362f5a99bfadee5fd091d7db0a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>C1_FLAG_OVERFLOW</b>&#160;&#160;&#160;0x00000010</td></tr>
<tr class="memdesc:gaf1a388362f5a99bfadee5fd091d7db0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag recording overflow. <br /></td></tr>
<tr class="separator:gaf1a388362f5a99bfadee5fd091d7db0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4dfe00dbf8805543d700aaa38aab9a06"><td class="memItemLeft" align="right" valign="top"><a id="ga4dfe00dbf8805543d700aaa38aab9a06" name="ga4dfe00dbf8805543d700aaa38aab9a06"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>C1_FLAG_DIV_BY_0</b>&#160;&#160;&#160;0x00000020</td></tr>
<tr class="memdesc:ga4dfe00dbf8805543d700aaa38aab9a06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag recording division by zero. <br /></td></tr>
<tr class="separator:ga4dfe00dbf8805543d700aaa38aab9a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14804d73dd021c03a61b0300b1919d10"><td class="memItemLeft" align="right" valign="top"><a id="ga14804d73dd021c03a61b0300b1919d10" name="ga14804d73dd021c03a61b0300b1919d10"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>C1_FLAG_INVALID_OP</b>&#160;&#160;&#160;0x00000040</td></tr>
<tr class="memdesc:ga14804d73dd021c03a61b0300b1919d10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag recording invalid operation. <br /></td></tr>
<tr class="separator:ga14804d73dd021c03a61b0300b1919d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46e2d458d5f7b7f4d87f3d57a40dfff6"><td class="memItemLeft" align="right" valign="top"><a id="ga46e2d458d5f7b7f4d87f3d57a40dfff6" name="ga46e2d458d5f7b7f4d87f3d57a40dfff6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>C1_ENABLE_INEXACT_OP</b>&#160;&#160;&#160;0x00000080</td></tr>
<tr class="memdesc:ga46e2d458d5f7b7f4d87f3d57a40dfff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable inexact operation exception. <br /></td></tr>
<tr class="separator:ga46e2d458d5f7b7f4d87f3d57a40dfff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19b0f817af7de65d59ac4791055b2a58"><td class="memItemLeft" align="right" valign="top"><a id="ga19b0f817af7de65d59ac4791055b2a58" name="ga19b0f817af7de65d59ac4791055b2a58"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>C1_ENABLE_UNDERFLOW</b>&#160;&#160;&#160;0x00000100</td></tr>
<tr class="memdesc:ga19b0f817af7de65d59ac4791055b2a58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable underflow exception. <br /></td></tr>
<tr class="separator:ga19b0f817af7de65d59ac4791055b2a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7db1d00d5950c69cdcc1927eaa19147"><td class="memItemLeft" align="right" valign="top"><a id="gac7db1d00d5950c69cdcc1927eaa19147" name="gac7db1d00d5950c69cdcc1927eaa19147"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>C1_ENABLE_OVERFLOW</b>&#160;&#160;&#160;0x00000200</td></tr>
<tr class="memdesc:gac7db1d00d5950c69cdcc1927eaa19147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable overflow exception. <br /></td></tr>
<tr class="separator:gac7db1d00d5950c69cdcc1927eaa19147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a9b250dbec3cbd3f2143e9757a65467"><td class="memItemLeft" align="right" valign="top"><a id="ga7a9b250dbec3cbd3f2143e9757a65467" name="ga7a9b250dbec3cbd3f2143e9757a65467"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>C1_ENABLE_DIV_BY_0</b>&#160;&#160;&#160;0x00000400</td></tr>
<tr class="memdesc:ga7a9b250dbec3cbd3f2143e9757a65467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable division by zero exception. <br /></td></tr>
<tr class="separator:ga7a9b250dbec3cbd3f2143e9757a65467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ff39bd710730a8b87f1ac2b552cbcb0"><td class="memItemLeft" align="right" valign="top"><a id="ga6ff39bd710730a8b87f1ac2b552cbcb0" name="ga6ff39bd710730a8b87f1ac2b552cbcb0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>C1_ENABLE_INVALID_OP</b>&#160;&#160;&#160;0x00000800</td></tr>
<tr class="memdesc:ga6ff39bd710730a8b87f1ac2b552cbcb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable invalid operation exception. <br /></td></tr>
<tr class="separator:ga6ff39bd710730a8b87f1ac2b552cbcb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga238f18753e527278da527b5f9c27d366"><td class="memItemLeft" align="right" valign="top"><a id="ga238f18753e527278da527b5f9c27d366" name="ga238f18753e527278da527b5f9c27d366"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>C1_CAUSE_INEXACT_OP</b>&#160;&#160;&#160;0x00001000</td></tr>
<tr class="memdesc:ga238f18753e527278da527b5f9c27d366"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triggered inexact operation exception. <br /></td></tr>
<tr class="separator:ga238f18753e527278da527b5f9c27d366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga343536da77d54ddef60310c1221ea017"><td class="memItemLeft" align="right" valign="top"><a id="ga343536da77d54ddef60310c1221ea017" name="ga343536da77d54ddef60310c1221ea017"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>C1_CAUSE_UNDERFLOW</b>&#160;&#160;&#160;0x00002000</td></tr>
<tr class="memdesc:ga343536da77d54ddef60310c1221ea017"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triggered underflow exception. <br /></td></tr>
<tr class="separator:ga343536da77d54ddef60310c1221ea017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4faa6db2dcd5a29fe4a2076973bf851"><td class="memItemLeft" align="right" valign="top"><a id="gae4faa6db2dcd5a29fe4a2076973bf851" name="gae4faa6db2dcd5a29fe4a2076973bf851"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>C1_CAUSE_OVERFLOW</b>&#160;&#160;&#160;0x00004000</td></tr>
<tr class="memdesc:gae4faa6db2dcd5a29fe4a2076973bf851"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triggered overflow exception. <br /></td></tr>
<tr class="separator:gae4faa6db2dcd5a29fe4a2076973bf851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb393a21a2e6a53afe9e719b91b445af"><td class="memItemLeft" align="right" valign="top"><a id="gafb393a21a2e6a53afe9e719b91b445af" name="gafb393a21a2e6a53afe9e719b91b445af"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>C1_CAUSE_DIV_BY_0</b>&#160;&#160;&#160;0x00008000</td></tr>
<tr class="memdesc:gafb393a21a2e6a53afe9e719b91b445af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triggered division by zero exception. <br /></td></tr>
<tr class="separator:gafb393a21a2e6a53afe9e719b91b445af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ce81d8eb4eb52edd14b0d0a72af590b"><td class="memItemLeft" align="right" valign="top"><a id="ga1ce81d8eb4eb52edd14b0d0a72af590b" name="ga1ce81d8eb4eb52edd14b0d0a72af590b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>C1_CAUSE_INVALID_OP</b>&#160;&#160;&#160;0x00010000</td></tr>
<tr class="memdesc:ga1ce81d8eb4eb52edd14b0d0a72af590b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triggered invalid operation exception. <br /></td></tr>
<tr class="separator:ga1ce81d8eb4eb52edd14b0d0a72af590b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38cb6567427a29005e6e26ffad360b99"><td class="memItemLeft" align="right" valign="top"><a id="ga38cb6567427a29005e6e26ffad360b99" name="ga38cb6567427a29005e6e26ffad360b99"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>C1_CAUSE_NOT_IMPLEMENTED</b>&#160;&#160;&#160;0x00020000</td></tr>
<tr class="memdesc:ga38cb6567427a29005e6e26ffad360b99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triggered not implemented exception. <br /></td></tr>
<tr class="separator:ga38cb6567427a29005e6e26ffad360b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga920f17acde0b8103c5f3b1be01d4e58a"><td class="memItemLeft" align="right" valign="top"><a id="ga920f17acde0b8103c5f3b1be01d4e58a" name="ga920f17acde0b8103c5f3b1be01d4e58a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>C1_FCR31_FS</b>&#160;&#160;&#160;(1&lt;&lt;24)</td></tr>
<tr class="memdesc:ga920f17acde0b8103c5f3b1be01d4e58a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush denormals to zero/min. <br /></td></tr>
<tr class="separator:ga920f17acde0b8103c5f3b1be01d4e58a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga758229d53dff85ac6a47956d61e96d4d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__n64sys.html#ga758229d53dff85ac6a47956d61e96d4d">C1_FCR31</a>()</td></tr>
<tr class="memdesc:ga758229d53dff85ac6a47956d61e96d4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the COP1 FCR31 register (floating-point control register 31)  <a href="group__n64sys.html#ga758229d53dff85ac6a47956d61e96d4d">More...</a><br /></td></tr>
<tr class="separator:ga758229d53dff85ac6a47956d61e96d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab48e93eec5c113af76e9592b5a3042f1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__n64sys.html#gab48e93eec5c113af76e9592b5a3042f1">C1_WRITE_FCR31</a>(x)</td></tr>
<tr class="memdesc:gab48e93eec5c113af76e9592b5a3042f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write to the COP1 FCR31 register.  <a href="group__n64sys.html#gab48e93eec5c113af76e9592b5a3042f1">More...</a><br /></td></tr>
<tr class="separator:gab48e93eec5c113af76e9592b5a3042f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf73acdf7fb3be35ff98322b7e827d349"><td class="memItemLeft" align="right" valign="top"><a id="gaf73acdf7fb3be35ff98322b7e827d349" name="gaf73acdf7fb3be35ff98322b7e827d349"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CPU_FREQUENCY</b>&#160;&#160;&#160;(<a class="el" href="group__n64sys.html#gacd3b316e4428bf20c80fa403921feeb5">__bbplayer</a> ? 140625000 : 93750000)</td></tr>
<tr class="memdesc:gaf73acdf7fb3be35ff98322b7e827d349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frequency of the MIPS R4300 CPU. <br /></td></tr>
<tr class="separator:gaf73acdf7fb3be35ff98322b7e827d349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f0580f61dc7654194a76aed5b60b362"><td class="memItemLeft" align="right" valign="top"><a id="ga3f0580f61dc7654194a76aed5b60b362" name="ga3f0580f61dc7654194a76aed5b60b362"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>KSEG0_START_ADDR</b>&#160;&#160;&#160;((void*)0x80000000)</td></tr>
<tr class="memdesc:ga3f0580f61dc7654194a76aed5b60b362"><td class="mdescLeft">&#160;</td><td class="mdescRight">void pointer to cached and non-mapped memory start address <br /></td></tr>
<tr class="separator:ga3f0580f61dc7654194a76aed5b60b362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a6fc83e86b9c1a343f50a219edd10c7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__n64sys.html#ga2a6fc83e86b9c1a343f50a219edd10c7">UncachedAddr</a>(_addr)&#160;&#160;&#160;((void *)(((unsigned long)(_addr))|0x20000000))</td></tr>
<tr class="memdesc:ga2a6fc83e86b9c1a343f50a219edd10c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the uncached memory address for a given address.  <a href="group__n64sys.html#ga2a6fc83e86b9c1a343f50a219edd10c7">More...</a><br /></td></tr>
<tr class="separator:ga2a6fc83e86b9c1a343f50a219edd10c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1557f26ee61d78b2efa5751fa324274"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__n64sys.html#gab1557f26ee61d78b2efa5751fa324274">UncachedShortAddr</a>(_addr)&#160;&#160;&#160;((short *)(((unsigned long)(_addr))|0x20000000))</td></tr>
<tr class="memdesc:gab1557f26ee61d78b2efa5751fa324274"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the uncached memory address for a given address.  <a href="group__n64sys.html#gab1557f26ee61d78b2efa5751fa324274">More...</a><br /></td></tr>
<tr class="separator:gab1557f26ee61d78b2efa5751fa324274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ecc863830830637fd78ceb0ba79760f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__n64sys.html#ga8ecc863830830637fd78ceb0ba79760f">UncachedUShortAddr</a>(_addr)&#160;&#160;&#160;((unsigned short *)(((unsigned long)(_addr))|0x20000000))</td></tr>
<tr class="memdesc:ga8ecc863830830637fd78ceb0ba79760f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the uncached memory address for a given address.  <a href="group__n64sys.html#ga8ecc863830830637fd78ceb0ba79760f">More...</a><br /></td></tr>
<tr class="separator:ga8ecc863830830637fd78ceb0ba79760f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacd99170f53fc12c555e2501f24f7d09"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__n64sys.html#gaacd99170f53fc12c555e2501f24f7d09">UncachedLongAddr</a>(_addr)&#160;&#160;&#160;((long *)(((unsigned long)(_addr))|0x20000000))</td></tr>
<tr class="memdesc:gaacd99170f53fc12c555e2501f24f7d09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the uncached memory address for a given address.  <a href="group__n64sys.html#gaacd99170f53fc12c555e2501f24f7d09">More...</a><br /></td></tr>
<tr class="separator:gaacd99170f53fc12c555e2501f24f7d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga925b2fcddd75e274b1588f3df87c3cfc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__n64sys.html#ga925b2fcddd75e274b1588f3df87c3cfc">UncachedULongAddr</a>(_addr)&#160;&#160;&#160;((unsigned long *)(((unsigned long)(_addr))|0x20000000))</td></tr>
<tr class="memdesc:ga925b2fcddd75e274b1588f3df87c3cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the uncached memory address for a given address.  <a href="group__n64sys.html#ga925b2fcddd75e274b1588f3df87c3cfc">More...</a><br /></td></tr>
<tr class="separator:ga925b2fcddd75e274b1588f3df87c3cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa566b86568181e152a0e5e940883600b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__n64sys.html#gaa566b86568181e152a0e5e940883600b">CachedAddr</a>(_addr)&#160;&#160;&#160;((void *)(((unsigned long)(_addr))&amp;~0x20000000))</td></tr>
<tr class="memdesc:gaa566b86568181e152a0e5e940883600b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cached memory address for a given address.  <a href="group__n64sys.html#gaa566b86568181e152a0e5e940883600b">More...</a><br /></td></tr>
<tr class="separator:gaa566b86568181e152a0e5e940883600b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54fca3c0f8e1be138f320b3dcce4366f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__n64sys.html#ga54fca3c0f8e1be138f320b3dcce4366f">PhysicalAddr</a>(_addr)</td></tr>
<tr class="memdesc:ga54fca3c0f8e1be138f320b3dcce4366f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the physical memory address for a given address.  <a href="group__n64sys.html#ga54fca3c0f8e1be138f320b3dcce4366f">More...</a><br /></td></tr>
<tr class="separator:ga54fca3c0f8e1be138f320b3dcce4366f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56d4cbe1e093c683432a147eb1ccb293"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__n64sys.html#ga56d4cbe1e093c683432a147eb1ccb293">MEMORY_BARRIER</a>()&#160;&#160;&#160;asm volatile (&quot;&quot; : : : &quot;memory&quot;)</td></tr>
<tr class="memdesc:ga56d4cbe1e093c683432a147eb1ccb293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory barrier to ensure in-order execution.  <a href="group__n64sys.html#ga56d4cbe1e093c683432a147eb1ccb293">More...</a><br /></td></tr>
<tr class="separator:ga56d4cbe1e093c683432a147eb1ccb293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f00b2f3f7a3bb391282d0b2da8969f1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__n64sys.html#ga3f00b2f3f7a3bb391282d0b2da8969f1">TICKS_READ</a>()&#160;&#160;&#160;<a class="el" href="group__n64sys.html#ga06cc6d925caa4db67e81281eef124d28">C0_COUNT</a>()</td></tr>
<tr class="memdesc:ga3f00b2f3f7a3bb391282d0b2da8969f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the COP0 register $9 (count).  <a href="group__n64sys.html#ga3f00b2f3f7a3bb391282d0b2da8969f1">More...</a><br /></td></tr>
<tr class="separator:ga3f00b2f3f7a3bb391282d0b2da8969f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dd7b7d41c220904632461a2d95d61cf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__n64sys.html#ga3dd7b7d41c220904632461a2d95d61cf">TICKS_PER_SECOND</a>&#160;&#160;&#160;(<a class="el" href="group__n64sys.html#gaf73acdf7fb3be35ff98322b7e827d349">CPU_FREQUENCY</a>/2)</td></tr>
<tr class="memdesc:ga3dd7b7d41c220904632461a2d95d61cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of updates to the count register per second.  <a href="group__n64sys.html#ga3dd7b7d41c220904632461a2d95d61cf">More...</a><br /></td></tr>
<tr class="separator:ga3dd7b7d41c220904632461a2d95d61cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39042176fdaeae838e23bf77575da2a7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__n64sys.html#ga39042176fdaeae838e23bf77575da2a7">TICKS_DISTANCE</a>(from,  to)&#160;&#160;&#160;((int32_t)((uint32_t)(to) - (uint32_t)(from)))</td></tr>
<tr class="memdesc:ga39042176fdaeae838e23bf77575da2a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The signed difference of time between "from" and "to".  <a href="group__n64sys.html#ga39042176fdaeae838e23bf77575da2a7">More...</a><br /></td></tr>
<tr class="separator:ga39042176fdaeae838e23bf77575da2a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f0c6ccf7791e58f7f392e6f733fc66b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__n64sys.html#ga5f0c6ccf7791e58f7f392e6f733fc66b">TICKS_BEFORE</a>(t1,  t2)&#160;&#160;&#160;({ <a class="el" href="group__n64sys.html#ga39042176fdaeae838e23bf77575da2a7">TICKS_DISTANCE</a>(t1, t2) &gt; 0; })</td></tr>
<tr class="memdesc:ga5f0c6ccf7791e58f7f392e6f733fc66b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if "t1" is before "t2".  <a href="group__n64sys.html#ga5f0c6ccf7791e58f7f392e6f733fc66b">More...</a><br /></td></tr>
<tr class="separator:ga5f0c6ccf7791e58f7f392e6f733fc66b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac393c76be44d9322b9b06c2b334f38ad"><td class="memItemLeft" align="right" valign="top"><a id="gac393c76be44d9322b9b06c2b334f38ad" name="gac393c76be44d9322b9b06c2b334f38ad"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TICKS_FROM_MS</b>(val)&#160;&#160;&#160;((uint32_t)((val) * (<a class="el" href="group__n64sys.html#ga3dd7b7d41c220904632461a2d95d61cf">TICKS_PER_SECOND</a> / 1000)))</td></tr>
<tr class="memdesc:gac393c76be44d9322b9b06c2b334f38ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns equivalent count ticks for the given millis. <br /></td></tr>
<tr class="separator:gac393c76be44d9322b9b06c2b334f38ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c4f1220d31e4e32d0586590c6a5b526"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__n64sys.html#ga6c4f1220d31e4e32d0586590c6a5b526">data_cache_hit_invalidate</a>(addr_,  sz_)</td></tr>
<tr class="memdesc:ga6c4f1220d31e4e32d0586590c6a5b526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force a data cache invalidate over a memory region.  <a href="group__n64sys.html#ga6c4f1220d31e4e32d0586590c6a5b526">More...</a><br /></td></tr>
<tr class="separator:ga6c4f1220d31e4e32d0586590c6a5b526"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga7f74bd3e9215d217f484cb5441a04e09"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__n64sys.html#ga7f74bd3e9215d217f484cb5441a04e09">tv_type_t</a> { <a class="el" href="group__n64sys.html#gga7f74bd3e9215d217f484cb5441a04e09a848a03bb41e5831799bcddab1e084d77">TV_PAL</a> = 0
, <a class="el" href="group__n64sys.html#gga7f74bd3e9215d217f484cb5441a04e09aa448059c396de3096b7f2cb91213effb">TV_NTSC</a> = 1
, <a class="el" href="group__n64sys.html#gga7f74bd3e9215d217f484cb5441a04e09a18303db5564bcb8858b073fd71299266">TV_MPAL</a> = 2
 }</td></tr>
<tr class="memdesc:ga7f74bd3e9215d217f484cb5441a04e09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of TV video output.  <a href="group__n64sys.html#ga7f74bd3e9215d217f484cb5441a04e09">More...</a><br /></td></tr>
<tr class="separator:ga7f74bd3e9215d217f484cb5441a04e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga599033222ecb746e183c1d30d1df5bc4"><td class="memItemLeft" align="right" valign="top"><a id="ga599033222ecb746e183c1d30d1df5bc4" name="ga599033222ecb746e183c1d30d1df5bc4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>sys_bbplayer</b> (void)</td></tr>
<tr class="memdesc:ga599033222ecb746e183c1d30d1df5bc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if we are running on a iQue player. <br /></td></tr>
<tr class="separator:ga599033222ecb746e183c1d30d1df5bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf0a7fb10dd4580b87d1c88536bf1ff2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__n64sys.html#gadf0a7fb10dd4580b87d1c88536bf1ff2">sys_get_boot_cic</a> ()</td></tr>
<tr class="memdesc:gadf0a7fb10dd4580b87d1c88536bf1ff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the boot CIC.  <a href="group__n64sys.html#gadf0a7fb10dd4580b87d1c88536bf1ff2">More...</a><br /></td></tr>
<tr class="separator:gadf0a7fb10dd4580b87d1c88536bf1ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3abd91a3b4d2ff33ad07556f7e7856e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__n64sys.html#gaa3abd91a3b4d2ff33ad07556f7e7856e">sys_set_boot_cic</a> (int bc)</td></tr>
<tr class="memdesc:gaa3abd91a3b4d2ff33ad07556f7e7856e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the boot CIC.  <a href="group__n64sys.html#gaa3abd91a3b4d2ff33ad07556f7e7856e">More...</a><br /></td></tr>
<tr class="separator:gaa3abd91a3b4d2ff33ad07556f7e7856e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc2164dd0c39d2d949291bb9b2379c0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__n64sys.html#gacc2164dd0c39d2d949291bb9b2379c0f">data_cache_hit_writeback</a> (volatile const void *addr, unsigned long length)</td></tr>
<tr class="memdesc:gacc2164dd0c39d2d949291bb9b2379c0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force a data cache writeback over a memory region.  <a href="group__n64sys.html#gacc2164dd0c39d2d949291bb9b2379c0f">More...</a><br /></td></tr>
<tr class="separator:gacc2164dd0c39d2d949291bb9b2379c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77626094fc3952fe3321098e24811e83"><td class="memItemLeft" align="right" valign="top"><a id="ga77626094fc3952fe3321098e24811e83" name="ga77626094fc3952fe3321098e24811e83"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>__data_cache_hit_invalidate</b> (volatile void *addr, unsigned long length)</td></tr>
<tr class="memdesc:ga77626094fc3952fe3321098e24811e83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Underlying implementation of data_cache_hit_invalidate. <br /></td></tr>
<tr class="separator:ga77626094fc3952fe3321098e24811e83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga477cecd8d83802c27a334edac9afe83a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__n64sys.html#ga477cecd8d83802c27a334edac9afe83a">data_cache_hit_writeback_invalidate</a> (volatile void *addr, unsigned long length)</td></tr>
<tr class="memdesc:ga477cecd8d83802c27a334edac9afe83a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force a data cache writeback invalidate over a memory region.  <a href="group__n64sys.html#ga477cecd8d83802c27a334edac9afe83a">More...</a><br /></td></tr>
<tr class="separator:ga477cecd8d83802c27a334edac9afe83a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65b4f6171cb8c4813576cd7925cb76de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__n64sys.html#ga65b4f6171cb8c4813576cd7925cb76de">data_cache_index_writeback_invalidate</a> (volatile void *addr, unsigned long length)</td></tr>
<tr class="memdesc:ga65b4f6171cb8c4813576cd7925cb76de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force a data cache index writeback invalidate over a memory region.  <a href="group__n64sys.html#ga65b4f6171cb8c4813576cd7925cb76de">More...</a><br /></td></tr>
<tr class="separator:ga65b4f6171cb8c4813576cd7925cb76de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa57816b81179fe22e8fc6b93f1e5cf69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__n64sys.html#gaa57816b81179fe22e8fc6b93f1e5cf69">data_cache_writeback_invalidate_all</a> (void)</td></tr>
<tr class="memdesc:gaa57816b81179fe22e8fc6b93f1e5cf69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force a data cache writeback invalidate over whole memory.  <a href="group__n64sys.html#gaa57816b81179fe22e8fc6b93f1e5cf69">More...</a><br /></td></tr>
<tr class="separator:gaa57816b81179fe22e8fc6b93f1e5cf69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac57f15648738d8f8575ec655a1678b73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__n64sys.html#gac57f15648738d8f8575ec655a1678b73">inst_cache_hit_writeback</a> (volatile const void *addr, unsigned long length)</td></tr>
<tr class="memdesc:gac57f15648738d8f8575ec655a1678b73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force an instruction cache writeback over a memory region.  <a href="group__n64sys.html#gac57f15648738d8f8575ec655a1678b73">More...</a><br /></td></tr>
<tr class="separator:gac57f15648738d8f8575ec655a1678b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c1668d8eee5e64ac7f3b91bd37db60e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__n64sys.html#ga6c1668d8eee5e64ac7f3b91bd37db60e">inst_cache_hit_invalidate</a> (volatile void *addr, unsigned long length)</td></tr>
<tr class="memdesc:ga6c1668d8eee5e64ac7f3b91bd37db60e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force an instruction cache invalidate over a memory region.  <a href="group__n64sys.html#ga6c1668d8eee5e64ac7f3b91bd37db60e">More...</a><br /></td></tr>
<tr class="separator:ga6c1668d8eee5e64ac7f3b91bd37db60e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7ec4cb3b1776373ede58525b43a258e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__n64sys.html#gae7ec4cb3b1776373ede58525b43a258e">inst_cache_index_invalidate</a> (volatile void *addr, unsigned long length)</td></tr>
<tr class="memdesc:gae7ec4cb3b1776373ede58525b43a258e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force an instruction cache index invalidate over a memory region.  <a href="group__n64sys.html#gae7ec4cb3b1776373ede58525b43a258e">More...</a><br /></td></tr>
<tr class="separator:gae7ec4cb3b1776373ede58525b43a258e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bbb609a58f6025ea3b8cb406ca4d823"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__n64sys.html#ga3bbb609a58f6025ea3b8cb406ca4d823">inst_cache_invalidate_all</a> (void)</td></tr>
<tr class="memdesc:ga3bbb609a58f6025ea3b8cb406ca4d823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force an instruction cache invalidate over whole memory.  <a href="group__n64sys.html#ga3bbb609a58f6025ea3b8cb406ca4d823">More...</a><br /></td></tr>
<tr class="separator:ga3bbb609a58f6025ea3b8cb406ca4d823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9f812fb3f12eaee7f5186b893266d3a"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__n64sys.html#gaf9f812fb3f12eaee7f5186b893266d3a">malloc_uncached</a> (size_t size)</td></tr>
<tr class="memdesc:gaf9f812fb3f12eaee7f5186b893266d3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a buffer that will be accessed as uncached memory.  <a href="group__n64sys.html#gaf9f812fb3f12eaee7f5186b893266d3a">More...</a><br /></td></tr>
<tr class="separator:gaf9f812fb3f12eaee7f5186b893266d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7eb2952f66b4c6158a161eddc6f6a7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__n64sys.html#gad7eb2952f66b4c6158a161eddc6f6a7d">free_uncached</a> (void *buf)</td></tr>
<tr class="memdesc:gad7eb2952f66b4c6158a161eddc6f6a7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free an uncached memory buffer.  <a href="group__n64sys.html#gad7eb2952f66b4c6158a161eddc6f6a7d">More...</a><br /></td></tr>
<tr class="separator:gad7eb2952f66b4c6158a161eddc6f6a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4496cbe7966a01738242c1b214028eb0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__n64sys.html#ga4496cbe7966a01738242c1b214028eb0">get_memory_size</a> ()</td></tr>
<tr class="memdesc:ga4496cbe7966a01738242c1b214028eb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get amount of available memory.  <a href="group__n64sys.html#ga4496cbe7966a01738242c1b214028eb0">More...</a><br /></td></tr>
<tr class="separator:ga4496cbe7966a01738242c1b214028eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28ba352e296d379426531772b874046d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__n64sys.html#ga28ba352e296d379426531772b874046d">is_memory_expanded</a> ()</td></tr>
<tr class="memdesc:ga28ba352e296d379426531772b874046d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is expansion pak in use.  <a href="group__n64sys.html#ga28ba352e296d379426531772b874046d">More...</a><br /></td></tr>
<tr class="separator:ga28ba352e296d379426531772b874046d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cd768cc5d84485110ecf4991727b00b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__n64sys.html#ga7f74bd3e9215d217f484cb5441a04e09">tv_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__n64sys.html#ga4cd768cc5d84485110ecf4991727b00b">get_tv_type</a> ()</td></tr>
<tr class="memdesc:ga4cd768cc5d84485110ecf4991727b00b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is system NTSC/PAL/MPAL.  <a href="group__n64sys.html#ga4cd768cc5d84485110ecf4991727b00b">More...</a><br /></td></tr>
<tr class="separator:ga4cd768cc5d84485110ecf4991727b00b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf92492d6d351321a5974768b17e16d82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__n64sys.html#gaf92492d6d351321a5974768b17e16d82">wait_ticks</a> (unsigned long <a class="el" href="group__system.html#ga6655447bab00753d59759423bf28e22e">wait</a>)</td></tr>
<tr class="memdesc:gaf92492d6d351321a5974768b17e16d82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spin wait until the number of ticks have elapsed.  <a href="group__n64sys.html#gaf92492d6d351321a5974768b17e16d82">More...</a><br /></td></tr>
<tr class="separator:gaf92492d6d351321a5974768b17e16d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ae016ad196fd951c5ce81d0f775f4ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__n64sys.html#ga2ae016ad196fd951c5ce81d0f775f4ed">wait_ms</a> (unsigned long wait_ms)</td></tr>
<tr class="memdesc:ga2ae016ad196fd951c5ce81d0f775f4ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spin wait until the number of milliseconds have elapsed.  <a href="group__n64sys.html#ga2ae016ad196fd951c5ce81d0f775f4ed">More...</a><br /></td></tr>
<tr class="separator:ga2ae016ad196fd951c5ce81d0f775f4ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d93c103e363e706bdafdc30601fcedd"><td class="memItemLeft" align="right" valign="top"><a id="ga6d93c103e363e706bdafdc30601fcedd" name="ga6d93c103e363e706bdafdc30601fcedd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>__init_cop1</b> ()</td></tr>
<tr class="memdesc:ga6d93c103e363e706bdafdc30601fcedd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize COP1 with default settings that prevent undesirable exceptions. <br /></td></tr>
<tr class="separator:ga6d93c103e363e706bdafdc30601fcedd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gacd3b316e4428bf20c80fa403921feeb5"><td class="memItemLeft" align="right" valign="top"><a id="gacd3b316e4428bf20c80fa403921feeb5" name="gacd3b316e4428bf20c80fa403921feeb5"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>__bbplayer</b> = 0</td></tr>
<tr class="memdesc:gacd3b316e4428bf20c80fa403921feeb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether we are running on a vanilla N64 or a iQue player. <br /></td></tr>
<tr class="separator:gacd3b316e4428bf20c80fa403921feeb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bde5bc5b3121ab6d4d1293f29a2718b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__n64sys.html#ga7bde5bc5b3121ab6d4d1293f29a2718b">__bootcic</a> = 6102</td></tr>
<tr class="memdesc:ga7bde5bc5b3121ab6d4d1293f29a2718b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boot CIC.  <a href="group__n64sys.html#ga7bde5bc5b3121ab6d4d1293f29a2718b">More...</a><br /></td></tr>
<tr class="separator:ga7bde5bc5b3121ab6d4d1293f29a2718b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd3b316e4428bf20c80fa403921feeb5"><td class="memItemLeft" align="right" valign="top"><a id="gacd3b316e4428bf20c80fa403921feeb5" name="gacd3b316e4428bf20c80fa403921feeb5"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>__bbplayer</b></td></tr>
<tr class="memdesc:gacd3b316e4428bf20c80fa403921feeb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether we are running on a vanilla N64 or a iQue player. <br /></td></tr>
<tr class="separator:gacd3b316e4428bf20c80fa403921feeb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >N64 bootup and cache interfaces. </p>
<p >The N64 system interface provides a way for code to interact with the memory setup on the system. This includes cache operations to invalidate or flush regions and the ability to set the boot CIC. The <a class="el" href="group__system.html">newlib Interface Hooks</a> use the knowledge of the boot CIC to properly determine if the expansion pak is present, giving 4MB of additional memory. Aside from this, the MIPS r4300 uses a manual cache management strategy, where SW that requires passing buffers to and from hardware components using DMA controllers needs to ensure that cache and RDRAM are in sync. A set of operations to invalidate and/or write back cache is provided for both instruction cache and data cache. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga2c0eaba2123f76f15834eab8e2a40e8c" name="ga2c0eaba2123f76f15834eab8e2a40e8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c0eaba2123f76f15834eab8e2a40e8c">&#9670;&nbsp;</a></span>C0_BADVADDR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define C0_BADVADDR</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    ({ \</div>
<div class="line">    uint32_t x; \</div>
<div class="line">    asm <span class="keyword">volatile</span>(<span class="stringliteral">&quot;mfc0 %0,$8&quot;</span> : <span class="stringliteral">&quot;=r&quot;</span> (x) : ); \</div>
<div class="line">    x; \</div>
<div class="line">})</div>
</div><!-- fragment -->
<p>Returns the COP0 register $8 (BadVAddr) </p>
<p >The coprocessor 0 (system control coprocessor - COP0) register $8 is a read only register holding the last virtual address to be translated which became invalid, or a virtual address for which an addressing error occurred. </p>

</div>
</div>
<a id="ga3207bfb3c7309dc93467172a04edcd67" name="ga3207bfb3c7309dc93467172a04edcd67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3207bfb3c7309dc93467172a04edcd67">&#9670;&nbsp;</a></span>C0_CAUSE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define C0_CAUSE</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    ({ \</div>
<div class="line">    uint32_t x; \</div>
<div class="line">    asm <span class="keyword">volatile</span>(<span class="stringliteral">&quot;mfc0 %0,$13&quot;</span> : <span class="stringliteral">&quot;=r&quot;</span> (x) : ); \</div>
<div class="line">    x; \</div>
<div class="line">})</div>
</div><!-- fragment -->
<p>Returns the COP0 register $13 (Cause Register) </p>
<p >The coprocessor 0 (system control coprocessor - COP0) register $13 is a read write register keeping pending interrupts, exception code, coprocessor unit number referenced for a coprocessor unusable exception.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__n64sys.html#ga2d7694469905182150475bac6179be6d" title="Get the exception code value from the COP0 status register value.">C0_GET_CAUSE_EXC_CODE</a>, <a class="el" href="group__n64sys.html#gab0ee128daa09f4992787f3d9a02130da" title="Get the CE value from the COP0 status register.">C0_GET_CAUSE_CE</a> and <a class="el" href="group__n64sys.html#gae5b5beedec5d8fb382744877c760c343" title="Cause: exception triggered in delay slot.">C0_CAUSE_BD</a> </dd></dl>

</div>
</div>
<a id="ga3ec3fa2068670095b1c6a07ff07a456b" name="ga3ec3fa2068670095b1c6a07ff07a456b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ec3fa2068670095b1c6a07ff07a456b">&#9670;&nbsp;</a></span>C0_COMPARE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define C0_COMPARE</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    ({ \</div>
<div class="line">    uint32_t x; \</div>
<div class="line">    asm <span class="keyword">volatile</span>(<span class="stringliteral">&quot;mfc0 %0,$11&quot;</span>:<span class="stringliteral">&quot;=r&quot;</span>(x)); \</div>
<div class="line">    x; \</div>
<div class="line">})</div>
</div><!-- fragment -->
<p>Read the COP0 Compare register. </p>

</div>
</div>
<a id="ga06cc6d925caa4db67e81281eef124d28" name="ga06cc6d925caa4db67e81281eef124d28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06cc6d925caa4db67e81281eef124d28">&#9670;&nbsp;</a></span>C0_COUNT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define C0_COUNT</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    ({ \</div>
<div class="line">    uint32_t x; \</div>
<div class="line">    asm <span class="keyword">volatile</span>(<span class="stringliteral">&quot;mfc0 %0,$9&quot;</span>:<span class="stringliteral">&quot;=r&quot;</span>(x)); \</div>
<div class="line">    x; \</div>
<div class="line">})</div>
</div><!-- fragment -->
<p>Read the COP0 Count register (see also TICKS_READ). </p>

</div>
</div>
<a id="ga019789477bcd2c33e7de911f61f928b3" name="ga019789477bcd2c33e7de911f61f928b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga019789477bcd2c33e7de911f61f928b3">&#9670;&nbsp;</a></span>C0_ENTRYHI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define C0_ENTRYHI</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    ({ \</div>
<div class="line">    uint32_t x; \</div>
<div class="line">    asm <span class="keyword">volatile</span>(<span class="stringliteral">&quot;mfc0 %0,$10&quot;</span>:<span class="stringliteral">&quot;=r&quot;</span>(x)); \</div>
<div class="line">    x; \</div>
<div class="line">})</div>
</div><!-- fragment -->
<p>Read the COP0 ENTRYHI register. </p>
<p >This register is used during TLB programming. It holds the configuration of the virtual memory entry for the TLB slot being accessed. </p>

</div>
</div>
<a id="ga161d0e63d1b4e2749984e9e548a993cb" name="ga161d0e63d1b4e2749984e9e548a993cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga161d0e63d1b4e2749984e9e548a993cb">&#9670;&nbsp;</a></span>C0_ENTRYLO0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define C0_ENTRYLO0</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    ({ \</div>
<div class="line">    uint32_t x; \</div>
<div class="line">    asm <span class="keyword">volatile</span>(<span class="stringliteral">&quot;mfc0 %0,$2&quot;</span>:<span class="stringliteral">&quot;=r&quot;</span>(x)); \</div>
<div class="line">    x; \</div>
<div class="line">})</div>
</div><!-- fragment -->
<p>Read the COP0 ENTRYLO0 register. </p>
<p >This register is used during TLB programming. It holds the configuration of the physical memory entry (even bank) for the TLB slot being accessed. </p>

</div>
</div>
<a id="ga5ee011d11bced21664d2c1cead5fb539" name="ga5ee011d11bced21664d2c1cead5fb539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ee011d11bced21664d2c1cead5fb539">&#9670;&nbsp;</a></span>C0_ENTRYLO1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define C0_ENTRYLO1</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    ({ \</div>
<div class="line">    uint32_t x; \</div>
<div class="line">    asm <span class="keyword">volatile</span>(<span class="stringliteral">&quot;mfc0 %0,$3&quot;</span>:<span class="stringliteral">&quot;=r&quot;</span>(x)); \</div>
<div class="line">    x; \</div>
<div class="line">})</div>
</div><!-- fragment -->
<p>Read the COP0 ENTRYLO1 register. </p>
<p >This register is used during TLB programming. It holds the configuration of the physical memory entry (odd bank) for the TLB slot being accessed. </p>

</div>
</div>
<a id="gaa7422a36ebf589991fa8408afdb100d5" name="gaa7422a36ebf589991fa8408afdb100d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7422a36ebf589991fa8408afdb100d5">&#9670;&nbsp;</a></span>C0_EPC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define C0_EPC</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    ({ \</div>
<div class="line">    uint32_t x; \</div>
<div class="line">    asm <span class="keyword">volatile</span>(<span class="stringliteral">&quot;mfc0 %0,$14&quot;</span> : <span class="stringliteral">&quot;=r&quot;</span> (x) : ); \</div>
<div class="line">    x; \</div>
<div class="line">})</div>
</div><!-- fragment -->
<p>Read the COP0 register $14 (EPC) </p>
<p >The coprocessor 0 (system control coprocessor - COP0) register $14 is the return from exception program counter. For asynchronous exceptions it points to the place to continue execution whereas for synchronous (caused by code) exceptions, point to the instruction causing the fault condition, which needs correction in the exception handler. This macro is for reading its value. </p>

</div>
</div>
<a id="gab0ee128daa09f4992787f3d9a02130da" name="gab0ee128daa09f4992787f3d9a02130da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0ee128daa09f4992787f3d9a02130da">&#9670;&nbsp;</a></span>C0_GET_CAUSE_CE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define C0_GET_CAUSE_CE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cr</td><td>)</td>
          <td>&#160;&#160;&#160;(((cr) &amp; <a class="el" href="group__n64sys.html#ga312cb5b3b8a176e307f05f7462b0b195">C0_CAUSE_CE</a>) &gt;&gt; 28)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the CE value from the COP0 status register. </p>
<p >Gets the Coprocessor unit number referenced by a coprocessor unusable exception from the given COP0 Status register value. </p>

</div>
</div>
<a id="ga8b28c8fdc6397b49616a494a69b7ea6d" name="ga8b28c8fdc6397b49616a494a69b7ea6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b28c8fdc6397b49616a494a69b7ea6d">&#9670;&nbsp;</a></span>C0_INDEX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define C0_INDEX</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    ({ \</div>
<div class="line">    uint32_t x; \</div>
<div class="line">    asm <span class="keyword">volatile</span>(<span class="stringliteral">&quot;mfc0 %0,$0&quot;</span>:<span class="stringliteral">&quot;=r&quot;</span>(x)); \</div>
<div class="line">    x; \</div>
<div class="line">})</div>
</div><!-- fragment -->
<p>Read the COP0 INDEX register. </p>
<p >This register is used during TLB programming. It holds the index of the TLB entry being accessed (0-31). </p>

</div>
</div>
<a id="ga0b305a5519adcf34759a3776854cacfd" name="ga0b305a5519adcf34759a3776854cacfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b305a5519adcf34759a3776854cacfd">&#9670;&nbsp;</a></span>C0_PAGEMASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define C0_PAGEMASK</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    ({ \</div>
<div class="line">    uint32_t x; \</div>
<div class="line">    asm <span class="keyword">volatile</span>(<span class="stringliteral">&quot;mfc0 %0,$5&quot;</span>:<span class="stringliteral">&quot;=r&quot;</span>(x)); \</div>
<div class="line">    x; \</div>
<div class="line">})</div>
</div><!-- fragment -->
<p>Read the COP0 PAGEMASK register. </p>
<p >This register is used during TLB programming. It holds the bitmask that configures the page size of the TLB slot being accessed. </p>

</div>
</div>
<a id="gaeeaf9cf4736be55054b718e5577618fc" name="gaeeaf9cf4736be55054b718e5577618fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeeaf9cf4736be55054b718e5577618fc">&#9670;&nbsp;</a></span>C0_STATUS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define C0_STATUS</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    ({ \</div>
<div class="line">    uint32_t x; \</div>
<div class="line">    asm <span class="keyword">volatile</span>(<span class="stringliteral">&quot;mfc0 %0,$12&quot;</span>:<span class="stringliteral">&quot;=r&quot;</span>(x)); \</div>
<div class="line">    x; \</div>
<div class="line">})</div>
</div><!-- fragment -->
<p>Read the COP0 Status register. </p>

</div>
</div>
<a id="gaba427de075f56d64d19af61b38821ae3" name="gaba427de075f56d64d19af61b38821ae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba427de075f56d64d19af61b38821ae3">&#9670;&nbsp;</a></span>C0_TLBP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define C0_TLBP</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;asm volatile(&quot;tlbp; nop; nop; nop; nop&quot;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>COP0 TLBP opcode. </p>
<p >This opcode is used during TLB programming. It probes the current TLB slots using ENTRYHI (virtual address) to find a matching slot. If it finds, it loads its index into INDEX. Otherwise, it sets the C0_INDEX_PROBE_FAILED bit in INDEX. </p>

</div>
</div>
<a id="gabb44eff79082cf67bcad321457adacb3" name="gabb44eff79082cf67bcad321457adacb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb44eff79082cf67bcad321457adacb3">&#9670;&nbsp;</a></span>C0_TLBR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define C0_TLBR</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;asm volatile(&quot;tlbr; nop; nop; nop; nop&quot;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>COP0 TLBR opcode. </p>
<p >This opcode is used during TLB programming. It reads the contents of the TLB slot referenced by INDEX into the registers PAGEMASK, ENTRYHI, ENTRYLO0 and ENTRYLO1. </p>

</div>
</div>
<a id="ga0c9067a58f6b9b4c3d89d3ec123de5ab" name="ga0c9067a58f6b9b4c3d89d3ec123de5ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c9067a58f6b9b4c3d89d3ec123de5ab">&#9670;&nbsp;</a></span>C0_TLBWI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define C0_TLBWI</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;asm volatile(&quot;tlbwi; nop; nop; nop; nop&quot;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>COP0 TLBWI opcode. </p>
<p >This opcode is used during TLB programming. It writes the TLB slot referenced by INDEX with the contents of PAGEMASK, ENTRYHI, ENTRYLO0, ENTRYLO1. </p>

</div>
</div>
<a id="ga9064781426b89fb32d4acd176604010d" name="ga9064781426b89fb32d4acd176604010d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9064781426b89fb32d4acd176604010d">&#9670;&nbsp;</a></span>C0_TLBWR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define C0_TLBWR</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;asm volatile(&quot;tlbwr; nop; nop; nop; nop&quot;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>COP0 TLBWR opcode. </p>
<p >This opcode is used during TLB programming. It writes a random TLB slot with the contents of PAGEMASK, ENTRYHI, ENTRYLO0, ENTRYLO1. THe slot is selected in the random pool (slots in the range from WIRED to 31). </p>

</div>
</div>
<a id="ga5fa34561986e5c2ba44159a362f65abb" name="ga5fa34561986e5c2ba44159a362f65abb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5fa34561986e5c2ba44159a362f65abb">&#9670;&nbsp;</a></span>C0_WIRED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define C0_WIRED</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    ({ \</div>
<div class="line">    uint32_t x; \</div>
<div class="line">    asm <span class="keyword">volatile</span>(<span class="stringliteral">&quot;mfc0 %0,$6&quot;</span>:<span class="stringliteral">&quot;=r&quot;</span>(x)); \</div>
<div class="line">    x; \</div>
<div class="line">})</div>
</div><!-- fragment -->
<p>Read the COP0 WIRED register. </p>
<p >This register is used during TLB programming. It allows to partition TLB slots between fixed slots and random slots. The fixed slot pool is the range [0..WIRED[ and the random pool is the range [WIRED..32[ </p>

</div>
</div>
<a id="gaa3ce6c31c752f1764961c80e054b2d40" name="gaa3ce6c31c752f1764961c80e054b2d40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3ce6c31c752f1764961c80e054b2d40">&#9670;&nbsp;</a></span>C0_WRITE_CAUSE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define C0_WRITE_CAUSE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    ({ \</div>
<div class="line">    asm <span class="keyword">volatile</span>(<span class="stringliteral">&quot;mtc0 %0,$13&quot;</span>::<span class="stringliteral">&quot;r&quot;</span>(x)); \</div>
<div class="line">})</div>
</div><!-- fragment -->
<p>Write the COP0 register $13 (Cause register) </p>
<p >Use this to update it for a custom exception handler. </p>

</div>
</div>
<a id="ga666712469205d6847d0120a7ac3e856d" name="ga666712469205d6847d0120a7ac3e856d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga666712469205d6847d0120a7ac3e856d">&#9670;&nbsp;</a></span>C0_WRITE_COMPARE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define C0_WRITE_COMPARE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    ({ \</div>
<div class="line">    asm <span class="keyword">volatile</span>(<span class="stringliteral">&quot;mtc0 %0,$11&quot;</span>::<span class="stringliteral">&quot;r&quot;</span>(x)); \</div>
<div class="line">})</div>
</div><!-- fragment -->
<p>Write the COP0 Compare register. </p>

</div>
</div>
<a id="ga69b664bbbc0e14604ecfd09623008fd6" name="ga69b664bbbc0e14604ecfd09623008fd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69b664bbbc0e14604ecfd09623008fd6">&#9670;&nbsp;</a></span>C0_WRITE_COUNT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define C0_WRITE_COUNT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    ({ \</div>
<div class="line">    asm <span class="keyword">volatile</span>(<span class="stringliteral">&quot;mtc0 %0,$9&quot;</span>::<span class="stringliteral">&quot;r&quot;</span>(x)); \</div>
<div class="line">})</div>
</div><!-- fragment -->
<p>Write the COP0 Count register. </p>

</div>
</div>
<a id="ga04b2274990f863599b9c9aba56d20c24" name="ga04b2274990f863599b9c9aba56d20c24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04b2274990f863599b9c9aba56d20c24">&#9670;&nbsp;</a></span>C0_WRITE_ENTRYHI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define C0_WRITE_ENTRYHI</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;asm volatile(&quot;mtc0 %0,$10; nop; nop&quot;::&quot;r&quot;(x))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the COP0 ENTRYHI register. </p>
<p >This register is used during TLB programming. </p>

</div>
</div>
<a id="gaf0400812af6bd1c9f594727092f22afb" name="gaf0400812af6bd1c9f594727092f22afb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0400812af6bd1c9f594727092f22afb">&#9670;&nbsp;</a></span>C0_WRITE_ENTRYLO0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define C0_WRITE_ENTRYLO0</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;asm volatile(&quot;mtc0 %0,$2; nop; nop&quot;::&quot;r&quot;(x))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the COP0 ENTRYLO0 register. </p>
<p >This register is used during TLB programming. It holds the configuration of the physical memory entry (even bank) for the TLB slot being accessed. </p>

</div>
</div>
<a id="ga21d4746ec6141ca47e79af8b3567cd21" name="ga21d4746ec6141ca47e79af8b3567cd21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21d4746ec6141ca47e79af8b3567cd21">&#9670;&nbsp;</a></span>C0_WRITE_ENTRYLO1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define C0_WRITE_ENTRYLO1</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;asm volatile(&quot;mtc0 %0,$3; nop; nop&quot;::&quot;r&quot;(x))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the COP0 ENTRYLO1 register. </p>
<p >This register is used during TLB programming. It holds the configuration of the physical memory entry (even bank) for the TLB slot being accessed. </p>

</div>
</div>
<a id="ga03738b353bc8fb592d1de0e04deab548" name="ga03738b353bc8fb592d1de0e04deab548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03738b353bc8fb592d1de0e04deab548">&#9670;&nbsp;</a></span>C0_WRITE_INDEX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define C0_WRITE_INDEX</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;asm volatile(&quot;mtc0 %0,$0; nop; nop&quot;::&quot;r&quot;(x))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the COP0 INDEX register. </p>
<p >This register is used during TLB programming. It holds the index of the TLB entry being accessed (0-31). </p>

</div>
</div>
<a id="gaea93ec852849f2ffd39dd8e8f20a33fc" name="gaea93ec852849f2ffd39dd8e8f20a33fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea93ec852849f2ffd39dd8e8f20a33fc">&#9670;&nbsp;</a></span>C0_WRITE_PAGEMASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define C0_WRITE_PAGEMASK</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;asm volatile(&quot;mtc0 %0,$5; nop; nop&quot;::&quot;r&quot;(x))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the COP0 PAGEMASK register. </p>
<p >This register is used during TLB programming. It holds the bitmask that configures the page size of the TLB slot being accessed. </p>

</div>
</div>
<a id="ga18dd4fdf1ca79c2976239698b8abdaac" name="ga18dd4fdf1ca79c2976239698b8abdaac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18dd4fdf1ca79c2976239698b8abdaac">&#9670;&nbsp;</a></span>C0_WRITE_STATUS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define C0_WRITE_STATUS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    ({ \</div>
<div class="line">    asm <span class="keyword">volatile</span>(<span class="stringliteral">&quot;mtc0 %0,$12&quot;</span>::<span class="stringliteral">&quot;r&quot;</span>(x)); \</div>
<div class="line">})</div>
</div><!-- fragment -->
<p>Write the COP0 Status register. </p>

</div>
</div>
<a id="gace54d6bc9240a2ca470d2312fd3bd5f3" name="gace54d6bc9240a2ca470d2312fd3bd5f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace54d6bc9240a2ca470d2312fd3bd5f3">&#9670;&nbsp;</a></span>C0_WRITE_WIRED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define C0_WRITE_WIRED</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;asm volatile(&quot;mtc0 %0,$6; nop; nop&quot;::&quot;r&quot;(x))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the COP0 WIRED register. </p>
<p >This register is used during TLB programming. It allows to partition TLB slots between fixed slots and random slots. The fixed slot pool is the range [0..WIRED[ and the random pool is the range [WIRED..32[ </p>

</div>
</div>
<a id="ga758229d53dff85ac6a47956d61e96d4d" name="ga758229d53dff85ac6a47956d61e96d4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga758229d53dff85ac6a47956d61e96d4d">&#9670;&nbsp;</a></span>C1_FCR31</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define C1_FCR31</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    ({ \</div>
<div class="line">    uint32_t x; \</div>
<div class="line">    asm <span class="keyword">volatile</span>(<span class="stringliteral">&quot;cfc1 %0,$f31&quot;</span>:<span class="stringliteral">&quot;=r&quot;</span>(x)); \</div>
<div class="line">    x; \</div>
<div class="line">})</div>
</div><!-- fragment -->
<p>Read the COP1 FCR31 register (floating-point control register 31) </p>
<p >FCR31 is also known as the Control/Status register. It keeps control and status data for the FPU. </p>

</div>
</div>
<a id="gab48e93eec5c113af76e9592b5a3042f1" name="gab48e93eec5c113af76e9592b5a3042f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab48e93eec5c113af76e9592b5a3042f1">&#9670;&nbsp;</a></span>C1_WRITE_FCR31</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define C1_WRITE_FCR31</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    ({ \</div>
<div class="line">    asm <span class="keyword">volatile</span>(<span class="stringliteral">&quot;ctc1 %0,$f31&quot;</span>::<span class="stringliteral">&quot;r&quot;</span>(x)); \</div>
<div class="line">})</div>
</div><!-- fragment -->
<p>Write to the COP1 FCR31 register. </p>

</div>
</div>
<a id="gac69e8a7b3752d227238ff76b56b3fa17" name="gac69e8a7b3752d227238ff76b56b3fa17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac69e8a7b3752d227238ff76b56b3fa17">&#9670;&nbsp;</a></span>cache_op</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define cache_op</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">op, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">linesize&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    ({ \</div>
<div class="line">    if (length) { \</div>
<div class="line">        void *cur = (<span class="keywordtype">void</span>*)((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)addr &amp; ~(linesize-1)); \</div>
<div class="line">        int count = (int)length + (addr-cur); \</div>
<div class="line">        for (<span class="keywordtype">int</span> i = 0; i &lt; count; i += linesize) \</div>
<div class="line">            <span class="keyword">asm</span> (<span class="stringliteral">&quot;\tcache %0,(%1)\n&quot;</span>::<span class="stringliteral">&quot;i&quot;</span> (op), <span class="stringliteral">&quot;r&quot;</span> (cur+i)); \</div>
<div class="line">    } \</div>
<div class="line">})</div>
</div><!-- fragment -->
<p>Helper macro to perform cache refresh operations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>Operation to perform </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">linesize</td><td>Size of a cacheline in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa566b86568181e152a0e5e940883600b" name="gaa566b86568181e152a0e5e940883600b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa566b86568181e152a0e5e940883600b">&#9670;&nbsp;</a></span>CachedAddr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CachedAddr</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_addr</td><td>)</td>
          <td>&#160;&#160;&#160;((void *)(((unsigned long)(_addr))&amp;~0x20000000))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the cached memory address for a given address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_addr</td><td>Address in RAM to convert to a cached address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A void pointer to the cached memory address in RAM </dd></dl>

</div>
</div>
<a id="ga6c4f1220d31e4e32d0586590c6a5b526" name="ga6c4f1220d31e4e32d0586590c6a5b526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c4f1220d31e4e32d0586590c6a5b526">&#9670;&nbsp;</a></span>data_cache_hit_invalidate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define data_cache_hit_invalidate</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">addr_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">sz_&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    ({ \</div>
<div class="line">    void *addr = (addr_); <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> sz = (sz_); \</div>
<div class="line">    assert(((uint32_t)addr % 16) == 0 &amp;&amp; (sz % 16) == 0); \</div>
<div class="line">    __data_cache_hit_invalidate(addr, sz); \</div>
<div class="line">})</div>
</div><!-- fragment -->
<p>Force a data cache invalidate over a memory region. </p>
<p >Use this to force the N64 to update cache from RDRAM.</p>
<p >The cache is made by cachelines of 16 bytes. If a memory region is invalidated and the memory region is not fully aligned to cachelines, a larger area than that requested will be invalidated; depending on the arrangement of the data segments and/or heap, this might make data previously written by the CPU in regular memory locations to be unexpectedly discarded, causing bugs.</p>
<p >For this reason, this function must only be called with an address aligned to 16 bytes, and with a length which is an exact multiple of 16 bytes; it will assert otherwise.</p>
<p >As an alternative, consider using <a class="el" href="group__n64sys.html#ga477cecd8d83802c27a334edac9afe83a" title="Force a data cache writeback invalidate over a memory region.">data_cache_hit_writeback_invalidate</a>, that first writebacks the affected cachelines to RDRAM, guaranteeing integrity of memory areas that share cachelines with the region that must be invalidated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr_</td><td>Pointer to memory in question </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sz_</td><td>Length in bytes of the data pointed at by addr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga56d4cbe1e093c683432a147eb1ccb293" name="ga56d4cbe1e093c683432a147eb1ccb293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56d4cbe1e093c683432a147eb1ccb293">&#9670;&nbsp;</a></span>MEMORY_BARRIER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEMORY_BARRIER</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;asm volatile (&quot;&quot; : : : &quot;memory&quot;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Memory barrier to ensure in-order execution. </p>
<p >Since GCC seems to reorder volatile at -O2, a memory barrier is required to ensure that DMA setup is done in the correct order. Otherwise, the library is useless at higher optimization levels. </p>

</div>
</div>
<a id="ga54fca3c0f8e1be138f320b3dcce4366f" name="ga54fca3c0f8e1be138f320b3dcce4366f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54fca3c0f8e1be138f320b3dcce4366f">&#9670;&nbsp;</a></span>PhysicalAddr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PhysicalAddr</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_addr</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    ({ \</div>
<div class="line">    const <span class="keyword">volatile</span> <span class="keywordtype">void</span> *_addrp = (_addr); \</div>
<div class="line">    (((<span class="keywordtype">unsigned</span> long)(_addrp))&amp;~0xE0000000); \</div>
<div class="line">})</div>
</div><!-- fragment -->
<p>Return the physical memory address for a given address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_addr</td><td>Address in RAM to convert to a physical address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A void pointer to the physical memory address in RAM </dd></dl>

</div>
</div>
<a id="ga5f0c6ccf7791e58f7f392e6f733fc66b" name="ga5f0c6ccf7791e58f7f392e6f733fc66b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f0c6ccf7791e58f7f392e6f733fc66b">&#9670;&nbsp;</a></span>TICKS_BEFORE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TICKS_BEFORE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">t1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">t2&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;({ <a class="el" href="group__n64sys.html#ga39042176fdaeae838e23bf77575da2a7">TICKS_DISTANCE</a>(t1, t2) &gt; 0; })</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if "t1" is before "t2". </p>
<p >This is similar to t1 &lt; t2, but it correctly handles timer overflows which are very frequent. Notice that the N64 counter overflows every ~91 seconds, so it's not possible to compare times that are more than ~45 seconds apart. </p>

</div>
</div>
<a id="ga39042176fdaeae838e23bf77575da2a7" name="ga39042176fdaeae838e23bf77575da2a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39042176fdaeae838e23bf77575da2a7">&#9670;&nbsp;</a></span>TICKS_DISTANCE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TICKS_DISTANCE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">from, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">to&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((int32_t)((uint32_t)(to) - (uint32_t)(from)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The signed difference of time between "from" and "to". </p>
<p >If "from" is before "to", the distance in time is positive, otherwise it is negative. </p>

</div>
</div>
<a id="ga3dd7b7d41c220904632461a2d95d61cf" name="ga3dd7b7d41c220904632461a2d95d61cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3dd7b7d41c220904632461a2d95d61cf">&#9670;&nbsp;</a></span>TICKS_PER_SECOND</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TICKS_PER_SECOND&#160;&#160;&#160;(<a class="el" href="group__n64sys.html#gaf73acdf7fb3be35ff98322b7e827d349">CPU_FREQUENCY</a>/2)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of updates to the count register per second. </p>
<p >Every second, this many counts will have passed in the count register </p>

</div>
</div>
<a id="ga3f00b2f3f7a3bb391282d0b2da8969f1" name="ga3f00b2f3f7a3bb391282d0b2da8969f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f00b2f3f7a3bb391282d0b2da8969f1">&#9670;&nbsp;</a></span>TICKS_READ</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TICKS_READ</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__n64sys.html#ga06cc6d925caa4db67e81281eef124d28">C0_COUNT</a>()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the COP0 register $9 (count). </p>
<p >The coprocessor 0 (system control coprocessor - COP0) register $9 is incremented at "half maximum instruction issue rate" which is the processor clock speed (93.75MHz) divided by two. (also see TICKS_PER_SECOND) It will always produce a 32-bit unsigned value which overflows back to zero in 91.625 seconds. The counter will increment irrespective of instructions actually being executed. This macro is for reading that value. Do not use for comparison without special handling. </p>

</div>
</div>
<a id="ga2a6fc83e86b9c1a343f50a219edd10c7" name="ga2a6fc83e86b9c1a343f50a219edd10c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a6fc83e86b9c1a343f50a219edd10c7">&#9670;&nbsp;</a></span>UncachedAddr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UncachedAddr</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_addr</td><td>)</td>
          <td>&#160;&#160;&#160;((void *)(((unsigned long)(_addr))|0x20000000))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the uncached memory address for a given address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_addr</td><td>Address in RAM to convert to an uncached address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A void pointer to the uncached memory address in RAM </dd></dl>

</div>
</div>
<a id="gaacd99170f53fc12c555e2501f24f7d09" name="gaacd99170f53fc12c555e2501f24f7d09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaacd99170f53fc12c555e2501f24f7d09">&#9670;&nbsp;</a></span>UncachedLongAddr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UncachedLongAddr</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_addr</td><td>)</td>
          <td>&#160;&#160;&#160;((long *)(((unsigned long)(_addr))|0x20000000))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the uncached memory address for a given address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_addr</td><td>Address in RAM to convert to an uncached address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A long pointer to the uncached memory address in RAM </dd></dl>

</div>
</div>
<a id="gab1557f26ee61d78b2efa5751fa324274" name="gab1557f26ee61d78b2efa5751fa324274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1557f26ee61d78b2efa5751fa324274">&#9670;&nbsp;</a></span>UncachedShortAddr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UncachedShortAddr</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_addr</td><td>)</td>
          <td>&#160;&#160;&#160;((short *)(((unsigned long)(_addr))|0x20000000))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the uncached memory address for a given address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_addr</td><td>Address in RAM to convert to an uncached address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A short pointer to the uncached memory address in RAM </dd></dl>

</div>
</div>
<a id="ga925b2fcddd75e274b1588f3df87c3cfc" name="ga925b2fcddd75e274b1588f3df87c3cfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga925b2fcddd75e274b1588f3df87c3cfc">&#9670;&nbsp;</a></span>UncachedULongAddr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UncachedULongAddr</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_addr</td><td>)</td>
          <td>&#160;&#160;&#160;((unsigned long *)(((unsigned long)(_addr))|0x20000000))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the uncached memory address for a given address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_addr</td><td>Address in RAM to convert to an uncached address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An unsigned long pointer to the uncached memory address in RAM </dd></dl>

</div>
</div>
<a id="ga8ecc863830830637fd78ceb0ba79760f" name="ga8ecc863830830637fd78ceb0ba79760f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ecc863830830637fd78ceb0ba79760f">&#9670;&nbsp;</a></span>UncachedUShortAddr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UncachedUShortAddr</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_addr</td><td>)</td>
          <td>&#160;&#160;&#160;((unsigned short *)(((unsigned long)(_addr))|0x20000000))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the uncached memory address for a given address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_addr</td><td>Address in RAM to convert to an uncached address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An unsigned short pointer to the uncached memory address in RAM </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga7f74bd3e9215d217f484cb5441a04e09" name="ga7f74bd3e9215d217f484cb5441a04e09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f74bd3e9215d217f484cb5441a04e09">&#9670;&nbsp;</a></span>tv_type_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__n64sys.html#ga7f74bd3e9215d217f484cb5441a04e09">tv_type_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of TV video output. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga7f74bd3e9215d217f484cb5441a04e09a848a03bb41e5831799bcddab1e084d77" name="gga7f74bd3e9215d217f484cb5441a04e09a848a03bb41e5831799bcddab1e084d77"></a>TV_PAL&#160;</td><td class="fielddoc"><p >Video output is PAL. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7f74bd3e9215d217f484cb5441a04e09aa448059c396de3096b7f2cb91213effb" name="gga7f74bd3e9215d217f484cb5441a04e09aa448059c396de3096b7f2cb91213effb"></a>TV_NTSC&#160;</td><td class="fielddoc"><p >Video output is NTSC. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7f74bd3e9215d217f484cb5441a04e09a18303db5564bcb8858b073fd71299266" name="gga7f74bd3e9215d217f484cb5441a04e09a18303db5564bcb8858b073fd71299266"></a>TV_MPAL&#160;</td><td class="fielddoc"><p >Video output is M-PAL. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gacc2164dd0c39d2d949291bb9b2379c0f" name="gacc2164dd0c39d2d949291bb9b2379c0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc2164dd0c39d2d949291bb9b2379c0f">&#9670;&nbsp;</a></span>data_cache_hit_writeback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void data_cache_hit_writeback </td>
          <td>(</td>
          <td class="paramtype">volatile const void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Force a data cache writeback over a memory region. </p>
<p >Use this to force cached memory to be written to RDRAM.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>Pointer to memory in question </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length in bytes of the data pointed at by addr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga477cecd8d83802c27a334edac9afe83a" name="ga477cecd8d83802c27a334edac9afe83a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga477cecd8d83802c27a334edac9afe83a">&#9670;&nbsp;</a></span>data_cache_hit_writeback_invalidate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void data_cache_hit_writeback_invalidate </td>
          <td>(</td>
          <td class="paramtype">volatile void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Force a data cache writeback invalidate over a memory region. </p>
<p >Use this to force cached memory to be written to RDRAM and then cache updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>Pointer to memory in question </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length in bytes of the data pointed at by addr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga65b4f6171cb8c4813576cd7925cb76de" name="ga65b4f6171cb8c4813576cd7925cb76de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65b4f6171cb8c4813576cd7925cb76de">&#9670;&nbsp;</a></span>data_cache_index_writeback_invalidate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void data_cache_index_writeback_invalidate </td>
          <td>(</td>
          <td class="paramtype">volatile void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Force a data cache index writeback invalidate over a memory region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>Pointer to memory in question </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length in bytes of the data pointed at by addr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa57816b81179fe22e8fc6b93f1e5cf69" name="gaa57816b81179fe22e8fc6b93f1e5cf69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa57816b81179fe22e8fc6b93f1e5cf69">&#9670;&nbsp;</a></span>data_cache_writeback_invalidate_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void data_cache_writeback_invalidate_all </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Force a data cache writeback invalidate over whole memory. </p>
<p >Also see <a class="el" href="group__n64sys.html#ga477cecd8d83802c27a334edac9afe83a" title="Force a data cache writeback invalidate over a memory region.">data_cache_hit_writeback_invalidate</a> </p>

</div>
</div>
<a id="gad7eb2952f66b4c6158a161eddc6f6a7d" name="gad7eb2952f66b4c6158a161eddc6f6a7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7eb2952f66b4c6158a161eddc6f6a7d">&#9670;&nbsp;</a></span>free_uncached()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void free_uncached </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free an uncached memory buffer. </p>
<p >This function frees a memory buffer previously allocated via <a class="el" href="group__n64sys.html#gaf9f812fb3f12eaee7f5186b893266d3a" title="Allocate a buffer that will be accessed as uncached memory.">malloc_uncached</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>The buffer to free</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__n64sys.html#gaf9f812fb3f12eaee7f5186b893266d3a" title="Allocate a buffer that will be accessed as uncached memory.">malloc_uncached</a> </dd></dl>

</div>
</div>
<a id="ga4496cbe7966a01738242c1b214028eb0" name="ga4496cbe7966a01738242c1b214028eb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4496cbe7966a01738242c1b214028eb0">&#9670;&nbsp;</a></span>get_memory_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int get_memory_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get amount of available memory. </p>
<dl class="section return"><dt>Returns</dt><dd>amount of total available memory in bytes. </dd></dl>

</div>
</div>
<a id="ga4cd768cc5d84485110ecf4991727b00b" name="ga4cd768cc5d84485110ecf4991727b00b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4cd768cc5d84485110ecf4991727b00b">&#9670;&nbsp;</a></span>get_tv_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__n64sys.html#ga7f74bd3e9215d217f484cb5441a04e09">tv_type_t</a> get_tv_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is system NTSC/PAL/MPAL. </p>
<p >Checks enum hard-coded in PIF BootROM to indicate the tv type of the system.</p>
<dl class="section return"><dt>Returns</dt><dd>enum value indicating PAL, NTSC or MPAL </dd></dl>

</div>
</div>
<a id="ga6c1668d8eee5e64ac7f3b91bd37db60e" name="ga6c1668d8eee5e64ac7f3b91bd37db60e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c1668d8eee5e64ac7f3b91bd37db60e">&#9670;&nbsp;</a></span>inst_cache_hit_invalidate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void inst_cache_hit_invalidate </td>
          <td>(</td>
          <td class="paramtype">volatile void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Force an instruction cache invalidate over a memory region. </p>
<p >Use this to force the N64 to update cache from RDRAM.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>Pointer to memory in question </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length in bytes of the data pointed at by addr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac57f15648738d8f8575ec655a1678b73" name="gac57f15648738d8f8575ec655a1678b73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac57f15648738d8f8575ec655a1678b73">&#9670;&nbsp;</a></span>inst_cache_hit_writeback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void inst_cache_hit_writeback </td>
          <td>(</td>
          <td class="paramtype">volatile const void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Force an instruction cache writeback over a memory region. </p>
<p >Use this to force cached memory to be written to RDRAM.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>Pointer to memory in question </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length in bytes of the data pointed at by addr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae7ec4cb3b1776373ede58525b43a258e" name="gae7ec4cb3b1776373ede58525b43a258e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7ec4cb3b1776373ede58525b43a258e">&#9670;&nbsp;</a></span>inst_cache_index_invalidate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void inst_cache_index_invalidate </td>
          <td>(</td>
          <td class="paramtype">volatile void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Force an instruction cache index invalidate over a memory region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>Pointer to memory in question </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length in bytes of the data pointed at by addr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3bbb609a58f6025ea3b8cb406ca4d823" name="ga3bbb609a58f6025ea3b8cb406ca4d823"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3bbb609a58f6025ea3b8cb406ca4d823">&#9670;&nbsp;</a></span>inst_cache_invalidate_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void inst_cache_invalidate_all </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Force an instruction cache invalidate over whole memory. </p>
<p >Also see <a class="el" href="group__n64sys.html#ga6c1668d8eee5e64ac7f3b91bd37db60e" title="Force an instruction cache invalidate over a memory region.">inst_cache_hit_invalidate</a> </p>

</div>
</div>
<a id="ga28ba352e296d379426531772b874046d" name="ga28ba352e296d379426531772b874046d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28ba352e296d379426531772b874046d">&#9670;&nbsp;</a></span>is_memory_expanded()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_memory_expanded </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is expansion pak in use. </p>
<p >Checks whether the maximum available memory has been expanded to 8MB</p>
<dl class="section return"><dt>Returns</dt><dd>true if expansion pak detected, false otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>On iQue, this function returns true only if the game has been assigned exactly 8MB of RAM. </dd></dl>

</div>
</div>
<a id="gaf9f812fb3f12eaee7f5186b893266d3a" name="gaf9f812fb3f12eaee7f5186b893266d3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9f812fb3f12eaee7f5186b893266d3a">&#9670;&nbsp;</a></span>malloc_uncached()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * malloc_uncached </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a buffer that will be accessed as uncached memory. </p>
<p >This function allocates a memory buffer that can be safely read and written through uncached memory accesses only. It makes sure that that the buffer does not share any cacheline with other buffers in the heap, and returns a pointer in the uncached segment (0xA0000000).</p>
<p >The buffer contents are uninitialized.</p>
<p >To free the buffer, use <a class="el" href="group__n64sys.html#gad7eb2952f66b4c6158a161eddc6f6a7d" title="Free an uncached memory buffer.">free_uncached</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size of the buffer to allocate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the start of the buffer (in the uncached segment)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__n64sys.html#gad7eb2952f66b4c6158a161eddc6f6a7d" title="Free an uncached memory buffer.">free_uncached</a> </dd></dl>

</div>
</div>
<a id="gadf0a7fb10dd4580b87d1c88536bf1ff2" name="gadf0a7fb10dd4580b87d1c88536bf1ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf0a7fb10dd4580b87d1c88536bf1ff2">&#9670;&nbsp;</a></span>sys_get_boot_cic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sys_get_boot_cic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the boot CIC. </p>
<dl class="section return"><dt>Returns</dt><dd>The boot CIC as an integer </dd></dl>

</div>
</div>
<a id="gaa3abd91a3b4d2ff33ad07556f7e7856e" name="gaa3abd91a3b4d2ff33ad07556f7e7856e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3abd91a3b4d2ff33ad07556f7e7856e">&#9670;&nbsp;</a></span>sys_set_boot_cic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sys_set_boot_cic </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the boot CIC. </p>
<p >This function will set the boot CIC. If the value isn't in the range of 6102-6106, the boot CIC is set to the default of 6102.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bc</td><td>Boot CIC value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2ae016ad196fd951c5ce81d0f775f4ed" name="ga2ae016ad196fd951c5ce81d0f775f4ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ae016ad196fd951c5ce81d0f775f4ed">&#9670;&nbsp;</a></span>wait_ms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wait_ms </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>wait_ms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Spin wait until the number of milliseconds have elapsed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">wait_ms</td><td>Number of milliseconds to wait Maximum accepted value is 91625 ms </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf92492d6d351321a5974768b17e16d82" name="gaf92492d6d351321a5974768b17e16d82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf92492d6d351321a5974768b17e16d82">&#9670;&nbsp;</a></span>wait_ticks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wait_ticks </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>wait</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Spin wait until the number of ticks have elapsed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">wait</td><td>Number of ticks to wait Maximum accepted value is 0xFFFFFFFF ticks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga7bde5bc5b3121ab6d4d1293f29a2718b" name="ga7bde5bc5b3121ab6d4d1293f29a2718b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7bde5bc5b3121ab6d4d1293f29a2718b">&#9670;&nbsp;</a></span>__bootcic</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int __bootcic = 6102</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Boot CIC. </p>
<p >Defaults to 6102. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jul 7 2022 08:55:10 for libdragon by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
