<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libdragon: DMA Controller</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">libdragon
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">DMA Controller<div class="ingroups"><a class="el" href="group__libdragon.html">libdragon</a> &raquo; <a class="el" href="group__lowlevel.html">Low Level Hardware Interfaces</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>DMA functionality for transfers between cartridge space and RDRAM.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="files" name="files"></a>
Files</h2></td></tr>
<tr class="memitem:dma_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dma_8c.html">dma.c</a></td></tr>
<tr class="memdesc:dma_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">DMA Controller. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:dma_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dma_8h.html">dma.h</a></td></tr>
<tr class="memdesc:dma_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">DMA Controller. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaa600a57f1b87a654aace331c12f3577a"><td class="memItemLeft" align="right" valign="top">volatile int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dma.html#gaa600a57f1b87a654aace331c12f3577a">dma_busy</a> (void)</td></tr>
<tr class="memdesc:gaa600a57f1b87a654aace331c12f3577a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether the DMA controller is currently busy.  <a href="group__dma.html#gaa600a57f1b87a654aace331c12f3577a">More...</a><br /></td></tr>
<tr class="separator:gaa600a57f1b87a654aace331c12f3577a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad868ada6b4e5c6eafb40a70f7377b900"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dma.html#gad868ada6b4e5c6eafb40a70f7377b900">dma_read_raw_async</a> (void *ram_address, unsigned long pi_address, unsigned long len)</td></tr>
<tr class="memdesc:gad868ada6b4e5c6eafb40a70f7377b900"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start reading data from a peripheral through PI DMA (low-level)  <a href="group__dma.html#gad868ada6b4e5c6eafb40a70f7377b900">More...</a><br /></td></tr>
<tr class="separator:gad868ada6b4e5c6eafb40a70f7377b900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cade71044285df66fb11e4187b8a09d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dma.html#ga2cade71044285df66fb11e4187b8a09d">dma_write_raw_async</a> (const void *ram_address, unsigned long pi_address, unsigned long len)</td></tr>
<tr class="memdesc:ga2cade71044285df66fb11e4187b8a09d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start writing data to a peripheral through PI DMA (low-level)  <a href="group__dma.html#ga2cade71044285df66fb11e4187b8a09d">More...</a><br /></td></tr>
<tr class="separator:ga2cade71044285df66fb11e4187b8a09d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67b2fbe3459597747359794ce2e3ddcc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dma.html#ga67b2fbe3459597747359794ce2e3ddcc">dma_read_async</a> (void *ram_address, unsigned long pi_address, unsigned long len)</td></tr>
<tr class="memdesc:ga67b2fbe3459597747359794ce2e3ddcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start reading data from a peripheral through PI DMA.  <a href="group__dma.html#ga67b2fbe3459597747359794ce2e3ddcc">More...</a><br /></td></tr>
<tr class="separator:ga67b2fbe3459597747359794ce2e3ddcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89a297ad5b901919cc3c44f08d16dfb0"><td class="memItemLeft" align="right" valign="top"><a id="ga89a297ad5b901919cc3c44f08d16dfb0" name="ga89a297ad5b901919cc3c44f08d16dfb0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dma_wait</b> (void)</td></tr>
<tr class="memdesc:ga89a297ad5b901919cc3c44f08d16dfb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until an async DMA transfer is finished. <br /></td></tr>
<tr class="separator:ga89a297ad5b901919cc3c44f08d16dfb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58b544e310a21cd57fe01da65cd27693"><td class="memItemLeft" align="right" valign="top"><a id="ga58b544e310a21cd57fe01da65cd27693" name="ga58b544e310a21cd57fe01da65cd27693"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dma_read</b> (void *ram_address, unsigned long pi_address, unsigned long len)</td></tr>
<tr class="memdesc:ga58b544e310a21cd57fe01da65cd27693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from a peripheral through PI DMA, waiting for completion. <br /></td></tr>
<tr class="separator:ga58b544e310a21cd57fe01da65cd27693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2af83b128e112eaaf3f27057e0042058"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dma.html#ga2af83b128e112eaaf3f27057e0042058">dma_write</a> (const void *ram_address, unsigned long pi_address, unsigned long len)</td></tr>
<tr class="memdesc:ga2af83b128e112eaaf3f27057e0042058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write to a peripheral.  <a href="group__dma.html#ga2af83b128e112eaaf3f27057e0042058">More...</a><br /></td></tr>
<tr class="separator:ga2af83b128e112eaaf3f27057e0042058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3594a5188d4cebfeab4ae572dfdeaf0d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dma.html#ga3594a5188d4cebfeab4ae572dfdeaf0d">io_read</a> (uint32_t pi_address)</td></tr>
<tr class="memdesc:ga3594a5188d4cebfeab4ae572dfdeaf0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a 32 bit integer from a peripheral.  <a href="group__dma.html#ga3594a5188d4cebfeab4ae572dfdeaf0d">More...</a><br /></td></tr>
<tr class="separator:ga3594a5188d4cebfeab4ae572dfdeaf0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5eb65e76faecd29c36757cdae3b6e36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dma.html#gac5eb65e76faecd29c36757cdae3b6e36">io_write</a> (uint32_t pi_address, uint32_t data)</td></tr>
<tr class="memdesc:gac5eb65e76faecd29c36757cdae3b6e36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a 32 bit integer to a peripheral.  <a href="group__dma.html#gac5eb65e76faecd29c36757cdae3b6e36">More...</a><br /></td></tr>
<tr class="separator:gac5eb65e76faecd29c36757cdae3b6e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">PI Status Register Bit Definitions</h2></td></tr>
<tr class="memitem:ga60d5ee8aff563bfe2a9a39fe86b524aa"><td class="memItemLeft" align="right" valign="top"><a id="ga60d5ee8aff563bfe2a9a39fe86b524aa" name="ga60d5ee8aff563bfe2a9a39fe86b524aa"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PI_STATUS_DMA_BUSY</b>&#160;&#160;&#160;( 1 &lt;&lt; 0 )</td></tr>
<tr class="memdesc:ga60d5ee8aff563bfe2a9a39fe86b524aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">PI DMA Busy. <br /></td></tr>
<tr class="separator:ga60d5ee8aff563bfe2a9a39fe86b524aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd66f53b97aed895b5d032c824bf384a"><td class="memItemLeft" align="right" valign="top"><a id="gacd66f53b97aed895b5d032c824bf384a" name="gacd66f53b97aed895b5d032c824bf384a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PI_STATUS_IO_BUSY</b>&#160;&#160;&#160;( 1 &lt;&lt; 1 )</td></tr>
<tr class="memdesc:gacd66f53b97aed895b5d032c824bf384a"><td class="mdescLeft">&#160;</td><td class="mdescRight">PI IO Busy. <br /></td></tr>
<tr class="separator:gacd66f53b97aed895b5d032c824bf384a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf401a56499cca3cc25b19defa3d5dcc8"><td class="memItemLeft" align="right" valign="top"><a id="gaf401a56499cca3cc25b19defa3d5dcc8" name="gaf401a56499cca3cc25b19defa3d5dcc8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PI_STATUS_ERROR</b>&#160;&#160;&#160;( 1 &lt;&lt; 2 )</td></tr>
<tr class="memdesc:gaf401a56499cca3cc25b19defa3d5dcc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">PI Error. <br /></td></tr>
<tr class="separator:gaf401a56499cca3cc25b19defa3d5dcc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >DMA functionality for transfers between cartridge space and RDRAM. </p>
<p >The DMA controller is responsible for handling block and word accesses from the catridge domain. Because of the nature of the catridge interface, code cannot use memcpy or standard pointer accesses on memory mapped to the catridge. Consequently, the peripheral interface (PI) provides a DMA controller for accessing data.</p>
<p >The DMA controller requires no initialization. Using <a class="el" href="group__dma.html#ga58b544e310a21cd57fe01da65cd27693" title="Read data from a peripheral through PI DMA, waiting for completion.">dma_read</a> and <a class="el" href="group__dma.html#ga2af83b128e112eaaf3f27057e0042058" title="Write to a peripheral.">dma_write</a> will allow reading from the cartridge and writing to the catridge respectively in block mode. <a class="el" href="group__dma.html#ga3594a5188d4cebfeab4ae572dfdeaf0d" title="Read a 32 bit integer from a peripheral.">io_read</a> and <a class="el" href="group__dma.html#gac5eb65e76faecd29c36757cdae3b6e36" title="Write a 32 bit integer to a peripheral.">io_write</a> will allow a single 32-bit integer to be read from or written to the cartridge. These are especially useful for manipulating registers on a cartridge such as a gameshark. Code should never make raw 32-bit reads or writes in the cartridge domain as it could collide with an in-progress DMA transfer or run into caching issues. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaa600a57f1b87a654aace331c12f3577a" name="gaa600a57f1b87a654aace331c12f3577a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa600a57f1b87a654aace331c12f3577a">&#9670;&nbsp;</a></span>dma_busy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile int dma_busy </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return whether the DMA controller is currently busy. </p>
<dl class="section return"><dt>Returns</dt><dd>nonzero if the DMA controller is busy or 0 otherwise </dd></dl>

</div>
</div>
<a id="ga67b2fbe3459597747359794ce2e3ddcc" name="ga67b2fbe3459597747359794ce2e3ddcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67b2fbe3459597747359794ce2e3ddcc">&#9670;&nbsp;</a></span>dma_read_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dma_read_async </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ram_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>pi_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start reading data from a peripheral through PI DMA. </p>
<p >This function must be used when reading a chunk of data from a cartridge peripheral (typically, ROM). It is a wrapper over <a class="el" href="group__dma.html#gad868ada6b4e5c6eafb40a70f7377b900" title="Start reading data from a peripheral through PI DMA (low-level)">dma_read_raw_async</a> that allows arbitrary aligned addresses and any length (including odd sizes). For fully-aligned addresses it quickly falls back to <a class="el" href="group__dma.html#gad868ada6b4e5c6eafb40a70f7377b900" title="Start reading data from a peripheral through PI DMA (low-level)">dma_read_raw_async</a>, so it can be used generically as "default" PI DMA transfer function.</p>
<p >The only constraint on alignment is that the RAM and PI addresses must have the same 1-bit misalignment, that is they must either be even addresses or odd addresses. Notice that this function will assert if this constraint is not respected.</p>
<p >Use <a class="el" href="group__dma.html#ga89a297ad5b901919cc3c44f08d16dfb0" title="Wait until an async DMA transfer is finished.">dma_wait</a> to wait for the end of the transfer.</p>
<p >For non performance sensitive tasks such as reading and parsing data from ROM at loading time, a better option is to use DragonFS, where <a class="el" href="group__dfs.html#ga7c0acaa1af10520da638633ab73b9287" title="Read data from a file.">dfs_read</a> falls back to a CPU memory copy to realign the data when required.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">ram_address</td><td>Pointer to a buffer to place read data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pi_address</td><td>Memory address of the peripheral to read from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length in bytes to read into ram_address </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad868ada6b4e5c6eafb40a70f7377b900" name="gad868ada6b4e5c6eafb40a70f7377b900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad868ada6b4e5c6eafb40a70f7377b900">&#9670;&nbsp;</a></span>dma_read_raw_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dma_read_raw_async </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ram_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>pi_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start reading data from a peripheral through PI DMA (low-level) </p>
<p >This function should be used when reading from a cartridge peripheral (typically ROM). This function just begins executing a raw DMA transfer, which is well-defined only for RAM addresses which are multiple of 8, ROM addresses which are multiple of 2, and lengths which are multiple of 2.</p>
<p >Use <a class="el" href="group__dma.html#ga89a297ad5b901919cc3c44f08d16dfb0" title="Wait until an async DMA transfer is finished.">dma_wait</a> to wait for the end of the transfer.</p>
<p >See <a class="el" href="group__dma.html#ga67b2fbe3459597747359794ce2e3ddcc" title="Start reading data from a peripheral through PI DMA.">dma_read_async</a> for a higher level primitive which can perform almost arbitrary transfers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">ram_address</td><td>Pointer to a buffer to place read data (must be 8-byte aligned) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pi_address</td><td>Memory address of the peripheral to read from (must be 2-byte aligned) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length in bytes to read into ram_address (must be multiple of 2) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2af83b128e112eaaf3f27057e0042058" name="ga2af83b128e112eaaf3f27057e0042058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2af83b128e112eaaf3f27057e0042058">&#9670;&nbsp;</a></span>dma_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dma_write </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ram_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>pi_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write to a peripheral. </p>
<p >This function should be used when writing to the cartridge.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ram_address</td><td>Pointer to a buffer to read data from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pi_address</td><td>Memory address of the peripheral to write to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length in bytes to write to peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2cade71044285df66fb11e4187b8a09d" name="ga2cade71044285df66fb11e4187b8a09d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2cade71044285df66fb11e4187b8a09d">&#9670;&nbsp;</a></span>dma_write_raw_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dma_write_raw_async </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ram_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>pi_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start writing data to a peripheral through PI DMA (low-level) </p>
<p >This function should be used when writing to a cartridge peripheral (typically ROM). This function just begins executing a raw DMA transfer, which is well-defined only for RAM addresses which are multiple of 8, ROM addresses which are multiple of 2, and lengths which are multiple of 2.</p>
<p >Use <a class="el" href="group__dma.html#ga89a297ad5b901919cc3c44f08d16dfb0" title="Wait until an async DMA transfer is finished.">dma_wait</a> to wait for the end of the transfer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">ram_address</td><td>Pointer to a buffer to read data from (must be 8-byte aligned) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pi_address</td><td>Memory address of the peripheral to write to (must be 2-byte aligned) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length in bytes to write into pi_address (must be multiple of 2) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3594a5188d4cebfeab4ae572dfdeaf0d" name="ga3594a5188d4cebfeab4ae572dfdeaf0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3594a5188d4cebfeab4ae572dfdeaf0d">&#9670;&nbsp;</a></span>io_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t io_read </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pi_address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a 32 bit integer from a peripheral. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pi_address</td><td>Memory address of the peripheral to read from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 32 bit value read from the peripheral </dd></dl>

</div>
</div>
<a id="gac5eb65e76faecd29c36757cdae3b6e36" name="gac5eb65e76faecd29c36757cdae3b6e36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5eb65e76faecd29c36757cdae3b6e36">&#9670;&nbsp;</a></span>io_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void io_write </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pi_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a 32 bit integer to a peripheral. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pi_address</td><td>Memory address of the peripheral to write to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>32 bit value to write to peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jul 7 2022 08:55:10 for libdragon by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
