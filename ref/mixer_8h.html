<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libdragon: mixer.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">libdragon
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">mixer.h File Reference<div class="ingroups"><a class="el" href="group__libdragon.html">libdragon</a> &raquo; <a class="el" href="group__audio.html">Audio Subsystem</a> &raquo; <a class="el" href="group__mixer.html">Audio mixer</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>RSP Audio mixer.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
</div>
<p><a href="mixer_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structwaveform__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mixer_8h.html#structwaveform__t">waveform_t</a></td></tr>
<tr class="memdesc:structwaveform__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">A waveform that can be played back through the mixer.  <a href="mixer_8h.html#structwaveform__t">More...</a><br /></td></tr>
<tr class="separator:structwaveform__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a8c4e507c0d1930fd5bd9a9d5f5ca3b13"><td class="memItemLeft" align="right" valign="top"><a id="a8c4e507c0d1930fd5bd9a9d5f5ca3b13" name="a8c4e507c0d1930fd5bd9a9d5f5ca3b13"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MIXER_MAX_CHANNELS</b>&#160;&#160;&#160;32</td></tr>
<tr class="memdesc:a8c4e507c0d1930fd5bd9a9d5f5ca3b13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of channels supported by the mixer. <br /></td></tr>
<tr class="separator:a8c4e507c0d1930fd5bd9a9d5f5ca3b13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ffdd651925d1fa7dc533602c508fc6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mixer_8h.html#a68ffdd651925d1fa7dc533602c508fc6">MIXER_LOOP_OVERREAD</a>&#160;&#160;&#160;64</td></tr>
<tr class="separator:a68ffdd651925d1fa7dc533602c508fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91f923e9b125bdd3b240842849fdbf3d"><td class="memItemLeft" align="right" valign="top"><a id="a91f923e9b125bdd3b240842849fdbf3d" name="a91f923e9b125bdd3b240842849fdbf3d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>WAVEFORM_MAX_LEN</b>&#160;&#160;&#160;0x1FFFFFFF</td></tr>
<tr class="memdesc:a91f923e9b125bdd3b240842849fdbf3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of samples in a waveform. <br /></td></tr>
<tr class="separator:a91f923e9b125bdd3b240842849fdbf3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a803ce99544a6087176fe7454c245dc77"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mixer_8h.html#a803ce99544a6087176fe7454c245dc77">WAVEFORM_UNKNOWN_LEN</a>&#160;&#160;&#160;<a class="el" href="mixer_8h.html#a91f923e9b125bdd3b240842849fdbf3d">WAVEFORM_MAX_LEN</a></td></tr>
<tr class="memdesc:a803ce99544a6087176fe7454c245dc77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify that the waveform length is unknown.  <a href="mixer_8h.html#a803ce99544a6087176fe7454c245dc77">More...</a><br /></td></tr>
<tr class="separator:a803ce99544a6087176fe7454c245dc77"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a509fb916b04893006f91d4bc5f7fc69e"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mixer_8h.html#a509fb916b04893006f91d4bc5f7fc69e">MixerEvent</a>) (void *ctx)</td></tr>
<tr class="memdesc:a509fb916b04893006f91d4bc5f7fc69e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback invoked by mixer_poll at a specified time.  <a href="mixer_8h.html#a509fb916b04893006f91d4bc5f7fc69e">More...</a><br /></td></tr>
<tr class="separator:a509fb916b04893006f91d4bc5f7fc69e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e995bf04880a3e14f689f48fdb2475"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mixer_8h.html#ab0e995bf04880a3e14f689f48fdb2475">WaveformRead</a>) (void *ctx, <a class="el" href="samplebuffer_8h.html#structsamplebuffer__t">samplebuffer_t</a> *sbuf, int wpos, int wlen, bool seeking)</td></tr>
<tr class="memdesc:ab0e995bf04880a3e14f689f48fdb2475"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waveform callback function invoked by the mixer to read/generate samples.  <a href="mixer_8h.html#ab0e995bf04880a3e14f689f48fdb2475">More...</a><br /></td></tr>
<tr class="separator:ab0e995bf04880a3e14f689f48fdb2475"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6d0758de0074e1a44dea7cf1b8d298d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mixer_8h.html#a6d0758de0074e1a44dea7cf1b8d298d5">mixer_init</a> (int num_channels)</td></tr>
<tr class="memdesc:a6d0758de0074e1a44dea7cf1b8d298d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the mixer.  <a href="mixer_8h.html#a6d0758de0074e1a44dea7cf1b8d298d5">More...</a><br /></td></tr>
<tr class="separator:a6d0758de0074e1a44dea7cf1b8d298d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a969649394d89cea7b84afc67db4d41d6"><td class="memItemLeft" align="right" valign="top"><a id="a969649394d89cea7b84afc67db4d41d6" name="a969649394d89cea7b84afc67db4d41d6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>mixer_close</b> (void)</td></tr>
<tr class="memdesc:a969649394d89cea7b84afc67db4d41d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deinitialize the mixer. <br /></td></tr>
<tr class="separator:a969649394d89cea7b84afc67db4d41d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ed9fdb3bfcb119d56764dd401848ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mixer_8h.html#ae8ed9fdb3bfcb119d56764dd401848ba">mixer_set_vol</a> (float vol)</td></tr>
<tr class="memdesc:ae8ed9fdb3bfcb119d56764dd401848ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set master volume.  <a href="mixer_8h.html#ae8ed9fdb3bfcb119d56764dd401848ba">More...</a><br /></td></tr>
<tr class="separator:ae8ed9fdb3bfcb119d56764dd401848ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56bc7f412e9cd0cde06c44e8acaa85ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mixer_8h.html#a56bc7f412e9cd0cde06c44e8acaa85ae">mixer_ch_set_vol</a> (int ch, float lvol, float rvol)</td></tr>
<tr class="memdesc:a56bc7f412e9cd0cde06c44e8acaa85ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set channel volume (as left/right).  <a href="mixer_8h.html#a56bc7f412e9cd0cde06c44e8acaa85ae">More...</a><br /></td></tr>
<tr class="separator:a56bc7f412e9cd0cde06c44e8acaa85ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fbe88215add4d8f5cd68807616ae9b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mixer_8h.html#a5fbe88215add4d8f5cd68807616ae9b1">mixer_ch_set_vol_pan</a> (int ch, float vol, float pan)</td></tr>
<tr class="memdesc:a5fbe88215add4d8f5cd68807616ae9b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set channel volume (as volume and panning).  <a href="mixer_8h.html#a5fbe88215add4d8f5cd68807616ae9b1">More...</a><br /></td></tr>
<tr class="separator:a5fbe88215add4d8f5cd68807616ae9b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf6854f30c27595b941525a6116c617"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mixer_8h.html#a9cf6854f30c27595b941525a6116c617">mixer_ch_set_vol_dolby</a> (int ch, float fl, float fr, float c, float sl, float sr)</td></tr>
<tr class="memdesc:a9cf6854f30c27595b941525a6116c617"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set channel volume with Dolby Pro Logic II encoding.  <a href="mixer_8h.html#a9cf6854f30c27595b941525a6116c617">More...</a><br /></td></tr>
<tr class="separator:a9cf6854f30c27595b941525a6116c617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa94701f22d086d624fb7d938ba0062"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mixer_8h.html#a1aa94701f22d086d624fb7d938ba0062">mixer_ch_play</a> (int ch, <a class="el" href="mixer_8h.html#structwaveform__t">waveform_t</a> *wave)</td></tr>
<tr class="memdesc:a1aa94701f22d086d624fb7d938ba0062"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start playing the specified waveform on the specified channel.  <a href="mixer_8h.html#a1aa94701f22d086d624fb7d938ba0062">More...</a><br /></td></tr>
<tr class="separator:a1aa94701f22d086d624fb7d938ba0062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c01ae2bc402901e8fbf7e61e5cd9d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mixer_8h.html#af8c01ae2bc402901e8fbf7e61e5cd9d6">mixer_ch_set_freq</a> (int ch, float frequency)</td></tr>
<tr class="memdesc:af8c01ae2bc402901e8fbf7e61e5cd9d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the frequency for the specified channel.  <a href="mixer_8h.html#af8c01ae2bc402901e8fbf7e61e5cd9d6">More...</a><br /></td></tr>
<tr class="separator:af8c01ae2bc402901e8fbf7e61e5cd9d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a827e0c459c6a250ccc74b977f9c64c5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mixer_8h.html#a827e0c459c6a250ccc74b977f9c64c5e">mixer_ch_set_pos</a> (int ch, float pos)</td></tr>
<tr class="memdesc:a827e0c459c6a250ccc74b977f9c64c5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the current playback position within a waveform.  <a href="mixer_8h.html#a827e0c459c6a250ccc74b977f9c64c5e">More...</a><br /></td></tr>
<tr class="separator:a827e0c459c6a250ccc74b977f9c64c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc8e8eb8b434ec042c44d8159648ef39"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mixer_8h.html#afc8e8eb8b434ec042c44d8159648ef39">mixer_ch_get_pos</a> (int ch)</td></tr>
<tr class="separator:afc8e8eb8b434ec042c44d8159648ef39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae21b093a1283e06ede42363498c490cb"><td class="memItemLeft" align="right" valign="top"><a id="ae21b093a1283e06ede42363498c490cb" name="ae21b093a1283e06ede42363498c490cb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>mixer_ch_stop</b> (int ch)</td></tr>
<tr class="memdesc:ae21b093a1283e06ede42363498c490cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop playing samples on the specified channel. <br /></td></tr>
<tr class="separator:ae21b093a1283e06ede42363498c490cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1893d5fc9d44b0e37ce0ef82afb71f37"><td class="memItemLeft" align="right" valign="top"><a id="a1893d5fc9d44b0e37ce0ef82afb71f37" name="a1893d5fc9d44b0e37ce0ef82afb71f37"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>mixer_ch_playing</b> (int ch)</td></tr>
<tr class="memdesc:a1893d5fc9d44b0e37ce0ef82afb71f37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the channel is currently playing samples. <br /></td></tr>
<tr class="separator:a1893d5fc9d44b0e37ce0ef82afb71f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6151c20fc5ddfa953c9d2dabe1da294"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mixer_8h.html#aa6151c20fc5ddfa953c9d2dabe1da294">mixer_ch_set_limits</a> (int ch, int max_bits, float max_frequency, int max_buf_sz)</td></tr>
<tr class="memdesc:aa6151c20fc5ddfa953c9d2dabe1da294"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the limits of a channel with respect to sample bit size, and frequency.  <a href="mixer_8h.html#aa6151c20fc5ddfa953c9d2dabe1da294">More...</a><br /></td></tr>
<tr class="separator:aa6151c20fc5ddfa953c9d2dabe1da294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49057735de9c408b332975d72c05390c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mixer_8h.html#a49057735de9c408b332975d72c05390c">mixer_poll</a> (int16_t *out, int nsamples)</td></tr>
<tr class="memdesc:a49057735de9c408b332975d72c05390c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the mixer to produce output samples.  <a href="mixer_8h.html#a49057735de9c408b332975d72c05390c">More...</a><br /></td></tr>
<tr class="separator:a49057735de9c408b332975d72c05390c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21ead4fd7433fbf4a328a216dc5a56a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mixer_8h.html#a21ead4fd7433fbf4a328a216dc5a56a8">mixer_add_event</a> (int64_t delay, <a class="el" href="mixer_8h.html#a509fb916b04893006f91d4bc5f7fc69e">MixerEvent</a> cb, void *ctx)</td></tr>
<tr class="memdesc:a21ead4fd7433fbf4a328a216dc5a56a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a time-based event into the mixer.  <a href="mixer_8h.html#a21ead4fd7433fbf4a328a216dc5a56a8">More...</a><br /></td></tr>
<tr class="separator:a21ead4fd7433fbf4a328a216dc5a56a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab616cf94c3df83670ca62236177b246"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mixer_8h.html#aab616cf94c3df83670ca62236177b246">mixer_remove_event</a> (<a class="el" href="mixer_8h.html#a509fb916b04893006f91d4bc5f7fc69e">MixerEvent</a> cb, void *ctx)</td></tr>
<tr class="memdesc:aab616cf94c3df83670ca62236177b246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deregister a time-based event from the mixer.  <a href="mixer_8h.html#aab616cf94c3df83670ca62236177b246">More...</a><br /></td></tr>
<tr class="separator:aab616cf94c3df83670ca62236177b246"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >RSP Audio mixer. </p>
</div><hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structwaveform__t" id="structwaveform__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structwaveform__t">&#9670;&nbsp;</a></span>waveform_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct waveform_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p >A waveform that can be played back through the mixer. </p>
<p ><a class="el" href="mixer_8h.html#structwaveform__t" title="A waveform that can be played back through the mixer.">waveform_t</a> represents a waveform that can be played back by the mixer. A <a class="el" href="mixer_8h.html#structwaveform__t" title="A waveform that can be played back through the mixer.">waveform_t</a> does not hold the actual samples because most real-world use cases do not keep all samples in memory, but rather load them and/or decompress them in real-time while the playback is happening. So <a class="el" href="mixer_8h.html#structwaveform__t" title="A waveform that can be played back through the mixer.">waveform_t</a> instead should be thought of as the generator of a waveform.</p>
<p >To create a waveform, use one of waveform implementations such as wav64. Waveform implementations are in charge of generating the samples by actually implementing an audio format like VADPCM or MPEG-2.</p>
<p >Waveforms can produce samples as 8-bit or 16-bit. Samples must always be signed. Stereo waveforms (interleaved samples) are supported: when used with <a class="el" href="mixer_8h.html#a1aa94701f22d086d624fb7d938ba0062" title="Start playing the specified waveform on the specified channel.">mixer_ch_play</a>, they will use automatically two channels (the specified one and the following). </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a1f19c0bdeedcaf8076b2c32ff9804005" name="a1f19c0bdeedcaf8076b2c32ff9804005"></a>uint8_t</td>
<td class="fieldname">
bits</td>
<td class="fielddoc">
Width of a sample of this waveform, in bits. <p >Supported values are 8 or 16. Notice that samples must always be signed. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a71d6099676db476a406a323e4e871a41" name="a71d6099676db476a406a323e4e871a41"></a>uint8_t</td>
<td class="fieldname">
channels</td>
<td class="fielddoc">
Number of interleaved audio channels in this waveforms. <p >Supported values are 1 and 2 (mono and stereo waveforms). Notice that a stereo waveform will use two consecutive mixer channels to be played back. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a1df77203f9cfc69e3772196faa5e1a9d" name="a1df77203f9cfc69e3772196faa5e1a9d"></a>void *</td>
<td class="fieldname">
ctx</td>
<td class="fielddoc">
Opaque pointer provided as context to the read function. </td></tr>
<tr><td class="fieldtype">
<a id="abf0009a0d23a1c1f93e21d64d7d18027" name="abf0009a0d23a1c1f93e21d64d7d18027"></a>float</td>
<td class="fieldname">
frequency</td>
<td class="fielddoc">
Desired playback frequency (in samples per second, aka Hz). </td></tr>
<tr><td class="fieldtype">
<a id="a85d404d379af0cb389239dc987496cb9" name="a85d404d379af0cb389239dc987496cb9"></a>int</td>
<td class="fieldname">
len</td>
<td class="fielddoc">
Length of the waveform, in number of samples. <p >If the length is not known, this value should be set to <a class="el" href="mixer_8h.html#a803ce99544a6087176fe7454c245dc77" title="Specify that the waveform length is unknown.">WAVEFORM_UNKNOWN_LEN</a>. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a4a7d318ddfbb4eeb1ec144f6163b5e15" name="a4a7d318ddfbb4eeb1ec144f6163b5e15"></a>int</td>
<td class="fieldname">
loop_len</td>
<td class="fielddoc">
Length of the loop of the waveform (from the end). <p >This value describes how many samples of the tail of the waveform needs to be played in a loop. For instance, if len==1200 and loop_len=500, the waveform will be played once, and then the last 700 samples will be repeated in loop. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="adb40944ddf35cee0a6cd8f135de2b8d8" name="adb40944ddf35cee0a6cd8f135de2b8d8"></a>const char *</td>
<td class="fieldname">
name</td>
<td class="fielddoc">
Name of the waveform (for debugging purposes) </td></tr>
<tr><td class="fieldtype">
<a id="a5bcbece8e4db3e873a29bb9a227ac4e4" name="a5bcbece8e4db3e873a29bb9a227ac4e4"></a><a class="el" href="mixer_8h.html#ab0e995bf04880a3e14f689f48fdb2475">WaveformRead</a></td>
<td class="fieldname">
read</td>
<td class="fielddoc">
Read function of the waveform. <p >This is the callback that will be invoked by the mixer to generate the samples. See <a class="el" href="mixer_8h.html#ab0e995bf04880a3e14f689f48fdb2475" title="Waveform callback function invoked by the mixer to read/generate samples.">WaveformRead</a> for more information. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a68ffdd651925d1fa7dc533602c508fc6" name="a68ffdd651925d1fa7dc533602c508fc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68ffdd651925d1fa7dc533602c508fc6">&#9670;&nbsp;</a></span>MIXER_LOOP_OVERREAD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MIXER_LOOP_OVERREAD&#160;&#160;&#160;64</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Number of bytes in sample buffers that must be over-read to make the RSP ucode safe.</p>
<p >RSP ucode doesn't currently bound check sample buffer accesses for performance reasons (and missing implementation). In case of loops, this means that the RSP will go beyond the loop end point, before looping, up to 64 bytes (which is the internal DMEM buffer, called DMEM_SAMPLE_CACHE).</p>
<p >So in general, when playing a looping waveform, the mixer will need to repeat the loop start after the loop end for up to 64 bytes. </p>

</div>
</div>
<a id="a803ce99544a6087176fe7454c245dc77" name="a803ce99544a6087176fe7454c245dc77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a803ce99544a6087176fe7454c245dc77">&#9670;&nbsp;</a></span>WAVEFORM_UNKNOWN_LEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WAVEFORM_UNKNOWN_LEN&#160;&#160;&#160;<a class="el" href="mixer_8h.html#a91f923e9b125bdd3b240842849fdbf3d">WAVEFORM_MAX_LEN</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify that the waveform length is unknown. </p>
<p >This value can be used in the "len" field of <a class="el" href="mixer_8h.html#structwaveform__t" title="A waveform that can be played back through the mixer.">waveform_t</a> to specify that the waveform length is unknown. The mixer will be unable to perform looping so the <a class="el" href="mixer_8h.html#ab0e995bf04880a3e14f689f48fdb2475" title="Waveform callback function invoked by the mixer to read/generate samples.">WaveformRead</a> function will have to handle looping by itself and/or generate silence once the playback is finished. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a509fb916b04893006f91d4bc5f7fc69e" name="a509fb916b04893006f91d4bc5f7fc69e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a509fb916b04893006f91d4bc5f7fc69e">&#9670;&nbsp;</a></span>MixerEvent</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* MixerEvent) (void *ctx)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback invoked by mixer_poll at a specified time. </p>
<p >A MixerEvent is a callback that is invoked during mixer_poll at a specified moment in time (that is, after a specified number of samples have been processed). It is useful to implement sequencers that need to update their status after a certain number of samples, or effects like volume envelopes that must update the channel volumes at regular intervals.</p>
<p >"ctx" is an opaque pointer that provides a context to the callback.</p>
<p >If the callback has finished its task, it can return 0 to deregister itself from the mixer. Otherwise, it can return a positive number of samples to wait before calling it again.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>Opaque pointer to provide context (specified in <a class="el" href="mixer_8h.html#a21ead4fd7433fbf4a328a216dc5a56a8" title="Register a time-based event into the mixer.">mixer_add_event</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the event can be deregistered, otherwise a positive number of samples to wait before calling again. </dd></dl>

</div>
</div>
<a id="ab0e995bf04880a3e14f689f48fdb2475" name="ab0e995bf04880a3e14f689f48fdb2475"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0e995bf04880a3e14f689f48fdb2475">&#9670;&nbsp;</a></span>WaveformRead</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* WaveformRead) (void *ctx, <a class="el" href="samplebuffer_8h.html#structsamplebuffer__t">samplebuffer_t</a> *sbuf, int wpos, int wlen, bool seeking)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waveform callback function invoked by the mixer to read/generate samples. </p>
<p >WaveformRead is a callback function that will be invoked by the mixer whenever a new unavailable portion of the waveform is requested.</p>
<p ><em>wpos</em> indicates the absolute position in the waveform from which the function must start reading, and <em>wlen</em> indicates the minimum number of samples to read.</p>
<p >The read function should push into the provided sample buffer at least <em>wlen</em> samples, using <a class="el" href="samplebuffer_8h.html#a392b4b826167c5157e983a18493cd4b5" title="Append samples into the buffer (zero-copy).">samplebuffer_append</a>. Producing more samples than requested is perfectly fine, they will be stored in the sample buffer and remain available for later use. For instance, a compressed waveform (eg: VADPCM) might decompress samples in blocks of fixed size, and thus push full blocks into the sample buffer, to avoid decoding a block twice.</p>
<p >On the contrary, producing less samples should only be done if the read function has absolutely no way to produce more. This should happen only when the stream is finished, and only when the waveform length was unknown to the mixer (otherwise, the mixer won't ask more samples than available in the first place).</p>
<p >The argument <em>seeking</em> is a flag that indicates whether the read being requested requires seeking or not. If <em>seeking</em> is false (most of the times), it means that the current read is requesting samples which come immediately after the ones that were last read; in other words, the implementation might decide to ignore the <em>wpos</em> argument and simply continue decoding the audio from the place were it last stopped. If <em>seeking</em> is true, instead, it means that there was a jump in position that should be taken into account.</p>
<p >Normally, a seeking is required in the following situations:</p>
<ul>
<li>At start (<a class="el" href="mixer_8h.html#a1aa94701f22d086d624fb7d938ba0062" title="Start playing the specified waveform on the specified channel.">mixer_ch_play</a>): the first read issued by the mixer will be at position 0 with <code>seeking == true</code> (unless the waveform was already partially cached in the sample buffer's channel).</li>
<li>At user request (<a class="el" href="mixer_8h.html#a827e0c459c6a250ccc74b977f9c64c5e" title="Change the current playback position within a waveform.">mixer_ch_set_pos</a>).</li>
<li>At loop: if a loop is specified in the waveform (<code>loop_len != 0</code>), the mixer will seek when required to execute the loop.</li>
</ul>
<p >Notice that producing more samples than requested in <em>wlen</em> might break the 8-byte buffer alignment guarantee that <a class="el" href="samplebuffer_8h.html#a392b4b826167c5157e983a18493cd4b5" title="Append samples into the buffer (zero-copy).">samplebuffer_append</a> tries to provide. For instance, if the read function is called requesting 24 samples, but it produces 25 samples instead, the alignment in the buffer will be lost, and next call to <a class="el" href="samplebuffer_8h.html#a392b4b826167c5157e983a18493cd4b5" title="Append samples into the buffer (zero-copy).">samplebuffer_append</a> will return an unaligned pointer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>Opaque pointer that is provided as context to the function, and is specified in the waveform. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sbuf</td><td>Samplebuffer into which read samples should be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wpos</td><td>Absolute position in the waveform to read from (in samples). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wlen</td><td>Minimum number of samples to read (in samples). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seeking</td><td>True if this call requires seeking in the waveform, false if this read is consecutive to the last one. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a21ead4fd7433fbf4a328a216dc5a56a8" name="a21ead4fd7433fbf4a328a216dc5a56a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21ead4fd7433fbf4a328a216dc5a56a8">&#9670;&nbsp;</a></span>mixer_add_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mixer_add_event </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>delay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mixer_8h.html#a509fb916b04893006f91d4bc5f7fc69e">MixerEvent</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a time-based event into the mixer. </p>
<p >Register a new event into the mixer. "delay" is the number of samples to wait before calling the event callback. "cb" is the event callback. "ctx" is an opaque pointer that will be passed to the callback when invoked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">delay</td><td>Number of samples to wait before invoking the event. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Event callback to invoke </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>Context opaque pointer to pass to the callback </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc8e8eb8b434ec042c44d8159648ef39" name="afc8e8eb8b434ec042c44d8159648ef39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc8e8eb8b434ec042c44d8159648ef39">&#9670;&nbsp;</a></span>mixer_ch_get_pos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float mixer_ch_get_pos </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Read the current playback position of the waveform in the channel.</p>
<p >The position is returned as number of samples. Fractional values account for accurate resampling position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ch</td><td>Channel index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Playback position (in number of samples) </dd></dl>

</div>
</div>
<a id="a1aa94701f22d086d624fb7d938ba0062" name="a1aa94701f22d086d624fb7d938ba0062"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aa94701f22d086d624fb7d938ba0062">&#9670;&nbsp;</a></span>mixer_ch_play()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mixer_ch_play </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mixer_8h.html#structwaveform__t">waveform_t</a> *&#160;</td>
          <td class="paramname"><em>wave</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start playing the specified waveform on the specified channel. </p>
<p >This function immediately begins playing the waveform, interrupting any other waveform that might have been reproduced on this channel.</p>
<p >Waveform settings are applied to the mixer channel; for instance, the frequency of the channel is modified to adapt to the frequency requested for correct playback of the waveform.</p>
<p >If the waveform is marked as stereo (channels == 2), the mixer will need two channels to play it back. "ch" will be used for the left samples, while "ch+1" will be used for the right samples. After this, it is forbidden to call mixer functions on "ch+1" until the stereo waveform is stopped.</p>
<p >If the same waveform (same pointer) was already being played or was the last one that was played on this channel, the channel sample buffer is retained, so that any cached samples might be reused.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ch</td><td>Channel index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wave</td><td>Waveform to playback </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af8c01ae2bc402901e8fbf7e61e5cd9d6" name="af8c01ae2bc402901e8fbf7e61e5cd9d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8c01ae2bc402901e8fbf7e61e5cd9d6">&#9670;&nbsp;</a></span>mixer_ch_set_freq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mixer_ch_set_freq </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>frequency</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the frequency for the specified channel. </p>
<p >By default, the frequency is the one required by the waveform associated to the channel, but this function allows to override.</p>
<p >This function must be called after mixer_ch_play, as otherwise the frequency is reset to the default of the waveform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ch</td><td>Channel index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frequency</td><td>Playback frequency (in Hz / samples per second) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa6151c20fc5ddfa953c9d2dabe1da294" name="aa6151c20fc5ddfa953c9d2dabe1da294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6151c20fc5ddfa953c9d2dabe1da294">&#9670;&nbsp;</a></span>mixer_ch_set_limits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mixer_ch_set_limits </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max_frequency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_buf_sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the limits of a channel with respect to sample bit size, and frequency. </p>
<p >This is an advanced function that should be used with caution, only in situations in which it is paramount to control the memory usage of the mixer.</p>
<p >By default, each channel in the mixer is capable of doing 16-bit playback with a frequency up to the mixer output sample rate (eg: 44100hz). This means that the mixer will allocate sample buffers required for this kind of capability.</p>
<p >If it is known that certain channels will use only 8-bit waveforms and/or a lower frequency, it is possible to call this function to inform the mixer of these limits. This will cause the mixer to reallocate the samplebuffers lowering its memory usage (note: multiple calls to this function for different channels will of course be batched to cause only one reallocation).</p>
<p >Note also that this function can be used to increase the maximum frequency over the mixer sample rate, in case this is required. This works correctly but since it causes downsampling, it is generally a waste of memory bandwidth and processing power.</p>
<p >"max_buf_sz" can be used to limit the maximum buffer size that will be allocated for this channel (in bytes). This is a hard cap, applied on top of the optimal buffer size that will be calculated by "max_bits" and "max_frequency", and can be used in situations where there are very strong memory constraints that must be respected. Use 0 if you don't want to impose a limit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ch</td><td>Channel index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_bits</td><td>Maximum number of bits per sample (or 0 to reset this to default, which is currently 16). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_frequency</td><td>Maximum playback frequency for this channel in Hz / samples per seconds (or 0 to reset this to default, which is the output sample rate as specified in <a class="el" href="group__audio.html#ga8ef2eb966a8552f3d19526753b98427f" title="Initialize the audio subsystem.">audio_init</a>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_buf_sz</td><td>Maximum buffer size in bytes (or o to reset this default, which is calculated using the other limites, the playback output rate, and the number of audio buffers specified in <a class="el" href="group__audio.html#ga8ef2eb966a8552f3d19526753b98427f" title="Initialize the audio subsystem.">audio_init</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a827e0c459c6a250ccc74b977f9c64c5e" name="a827e0c459c6a250ccc74b977f9c64c5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a827e0c459c6a250ccc74b977f9c64c5e">&#9670;&nbsp;</a></span>mixer_ch_set_pos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mixer_ch_set_pos </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the current playback position within a waveform. </p>
<p >This function can be useful to seek to a specific point of the waveform. The position must be specified in number of samples (not bytes). Fractional values account for accurate resampling position.</p>
<p >This function must be called after mixer_ch_play, as otherwise the position is reset to the beginning of the waveform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ch</td><td>Channel index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>Playback position (in number of samples) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56bc7f412e9cd0cde06c44e8acaa85ae" name="a56bc7f412e9cd0cde06c44e8acaa85ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56bc7f412e9cd0cde06c44e8acaa85ae">&#9670;&nbsp;</a></span>mixer_ch_set_vol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mixer_ch_set_vol </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>lvol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rvol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set channel volume (as left/right). </p>
<p >Configure channel volume for the specified channel, specifying two values: one for the left output and one for the right output.</p>
<p >The volume is an attenuation (no amplification is performed). Valid volume range in [0..1], where 0 is silence and 1 is original channel sample volume (no attenuation performed).</p>
<p >Notice that it's perfectly valid to set left/right volumes even if the channel itself will play a mono waveforms, as it allows to balance a mono sample between the two final output channels.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ch</td><td>Channel index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lvol</td><td>Left volume (range [0..1]) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rvol</td><td>Right volume (range [0..1]) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9cf6854f30c27595b941525a6116c617" name="a9cf6854f30c27595b941525a6116c617"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cf6854f30c27595b941525a6116c617">&#9670;&nbsp;</a></span>mixer_ch_set_vol_dolby()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mixer_ch_set_vol_dolby </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set channel volume with Dolby Pro Logic II encoding. </p>
<p >Configure the volumes of the specified channel according to the Dolby Pro Logic II matrix encoding. This allows to encode samples with a virtual surround system, that can be decoded with a Dolby 5.1 compatible equipment.</p>
<p >The function accepts the volumes configured for the 5 channels: front left, front right, center, surround left, surround right. These values can be calculated from a 3D scene</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ch</td><td>Channel index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fl</td><td>Front left volume (range [0..1]) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fr</td><td>Front right volume (range [0..1]) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>Central volume (range [0..1]) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sl</td><td>Surround left volume (range [0..1]) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sr</td><td>Surround right volume (range [0..1]) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5fbe88215add4d8f5cd68807616ae9b1" name="a5fbe88215add4d8f5cd68807616ae9b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fbe88215add4d8f5cd68807616ae9b1">&#9670;&nbsp;</a></span>mixer_ch_set_vol_pan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mixer_ch_set_vol_pan </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>vol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>pan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set channel volume (as volume and panning). </p>
<p >Configure the left and right channel volumes for the specified channel, Using a central volume value and a panning value to specify left/right balance.</p>
<p >Valid volume range in [0..1], where 0 is silence and 1 is maximum volume (no attenuation).</p>
<p >Valid panning range is [0..1] where 0 is 100% left, and 1 is 100% right.</p>
<p >Notice that panning 0.5 balance the sound but causes an attenuation of 50%.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ch</td><td>Channel index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vol</td><td>Central volume (range [0..1]) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pan</td><td>Panning (range [0..1], center is 0.5) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6d0758de0074e1a44dea7cf1b8d298d5" name="a6d0758de0074e1a44dea7cf1b8d298d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d0758de0074e1a44dea7cf1b8d298d5">&#9670;&nbsp;</a></span>mixer_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mixer_init </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_channels</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the mixer. </p>
<p >The mixer must be initialized after the audio subsystem (audio_init). The number of channels specified is the maximum number of channels used by the application. Specifying a higher number means using more memory as the mixer will allocate one sample buffer per channel, but it does not affect performance (which correlates to the actual number of simultaneously playing channels).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num_channels</td><td>Number of channels to initialize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a49057735de9c408b332975d72c05390c" name="a49057735de9c408b332975d72c05390c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49057735de9c408b332975d72c05390c">&#9670;&nbsp;</a></span>mixer_poll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mixer_poll </td>
          <td>(</td>
          <td class="paramtype">int16_t *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nsamples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run the mixer to produce output samples. </p>
<p >This function will fetch the required samples from all the channels and mix them together according to each channel's settings. The output will be written into the specified buffer (out). nsamples is the number of samples that should be produced.</p>
<p >A common pattern would be to call <a class="el" href="group__audio.html#ga8aee840f13aa6903fef4c092d0ffa704" title="Start writing to the first free internal buffer.">audio_write_begin</a> to obtain an audio buffer's pointer, and pass it to mixer_poll.</p>
<p >mixer_poll performs mixing using RSP. If RSP is busy, mixer_poll will spin-wait until the RSP is free, to perform audio processing.</p>
<p >Since the N64 AI can only be fed with an even number of samples, mixer_poll does not accept odd numbers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">out</td><td>Output buffer were samples will be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nsamples</td><td>Number of stereo samples to generate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab616cf94c3df83670ca62236177b246" name="aab616cf94c3df83670ca62236177b246"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab616cf94c3df83670ca62236177b246">&#9670;&nbsp;</a></span>mixer_remove_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mixer_remove_event </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mixer_8h.html#a509fb916b04893006f91d4bc5f7fc69e">MixerEvent</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deregister a time-based event from the mixer. </p>
<p >Deregister an event from the mixer. "cb" is the event callback, and "ctx" is the opaque context pointer. Notice that an event can also deregister itself by returning 0 when called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Callback that was registered via <a class="el" href="mixer_8h.html#a21ead4fd7433fbf4a328a216dc5a56a8" title="Register a time-based event into the mixer.">mixer_add_event</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>Opaque pointer that was registered with the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae8ed9fdb3bfcb119d56764dd401848ba" name="ae8ed9fdb3bfcb119d56764dd401848ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8ed9fdb3bfcb119d56764dd401848ba">&#9670;&nbsp;</a></span>mixer_set_vol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mixer_set_vol </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>vol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set master volume. </p>
<p >This is a global attenuation factor (range [0..1]) that will be applied to all channels and simplify implementing a global volume control.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vol</td><td>Master volume (range [0..1]) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jul 7 2022 08:55:10 for libdragon by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
