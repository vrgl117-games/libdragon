<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libdragon: samplebuffer.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">libdragon
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_a63dedf81f1e5ea1d42bb45ef831eb8c.html">audio</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">samplebuffer.c File Reference<div class="ingroups"><a class="el" href="group__libdragon.html">libdragon</a> &raquo; <a class="el" href="group__audio.html">Audio Subsystem</a> &raquo; <a class="el" href="group__mixer.html">Audio mixer</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Sample buffer.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="mixer_8h_source.html">mixer.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="samplebuffer_8h_source.html">samplebuffer.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="n64sys_8h_source.html">n64sys.h</a>&quot;</code><br />
<code>#include &quot;utils.h&quot;</code><br />
<code>#include &quot;<a class="el" href="debug_8h_source.html">debug.h</a>&quot;</code><br />
<code>#include &lt;string.h&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a51055c8e74be85f62c35632ff82e869f"><td class="memItemLeft" align="right" valign="top"><a id="a51055c8e74be85f62c35632ff82e869f" name="a51055c8e74be85f62c35632ff82e869f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MIXER_TRACE</b>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:a51055c8e74be85f62c35632ff82e869f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set to 1 to activate debug logs. <br /></td></tr>
<tr class="separator:a51055c8e74be85f62c35632ff82e869f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb613ddfceb7573a840c84b146f273c"><td class="memItemLeft" align="right" valign="top"><a id="a1fb613ddfceb7573a840c84b146f273c" name="a1fb613ddfceb7573a840c84b146f273c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>tracef</b>(fmt, ...)&#160;&#160;&#160;({ })</td></tr>
<tr class="memdesc:a1fb613ddfceb7573a840c84b146f273c"><td class="mdescLeft">&#160;</td><td class="mdescRight">like <a class="el" href="debug_8h.html#aa3e8be416ef1525cfd3230204b56d184" title="Write a message to the debugging channel.">debugf()</a>, but writes only if <a class="el" href="samplebuffer_8c.html#a51055c8e74be85f62c35632ff82e869f" title="Set to 1 to activate debug logs.">MIXER_TRACE</a> is not 0 <br /></td></tr>
<tr class="separator:a1fb613ddfceb7573a840c84b146f273c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a09536ab55339204e3392bdced7de21d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="samplebuffer_8c.html#a09536ab55339204e3392bdced7de21d1">samplebuffer_init</a> (<a class="el" href="samplebuffer_8h.html#structsamplebuffer__t">samplebuffer_t</a> *buf, uint8_t *uncached_mem, int nbytes)</td></tr>
<tr class="separator:a09536ab55339204e3392bdced7de21d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16bbcb1683deb8206e06bd9128f9b09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="samplebuffer_8c.html#aa16bbcb1683deb8206e06bd9128f9b09">samplebuffer_set_bps</a> (<a class="el" href="samplebuffer_8h.html#structsamplebuffer__t">samplebuffer_t</a> *buf, int bits_per_sample)</td></tr>
<tr class="memdesc:aa16bbcb1683deb8206e06bd9128f9b09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the bit width of the samples stored in the buffer.  <a href="samplebuffer_8c.html#aa16bbcb1683deb8206e06bd9128f9b09">More...</a><br /></td></tr>
<tr class="separator:aa16bbcb1683deb8206e06bd9128f9b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1ed7b8b55c07c6c6a4c6471e94e6145"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="samplebuffer_8c.html#ae1ed7b8b55c07c6c6a4c6471e94e6145">samplebuffer_set_waveform</a> (<a class="el" href="samplebuffer_8h.html#structsamplebuffer__t">samplebuffer_t</a> *buf, <a class="el" href="mixer_8h.html#ab0e995bf04880a3e14f689f48fdb2475">WaveformRead</a> <a class="el" href="group__system.html#gaa0c5d610f8b61891a7cf5fca2671b6f9">read</a>, void *ctx)</td></tr>
<tr class="separator:ae1ed7b8b55c07c6c6a4c6471e94e6145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4648f973933db48c4aa1c3252333e8c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="samplebuffer_8c.html#a4648f973933db48c4aa1c3252333e8c7">samplebuffer_close</a> (<a class="el" href="samplebuffer_8h.html#structsamplebuffer__t">samplebuffer_t</a> *buf)</td></tr>
<tr class="separator:a4648f973933db48c4aa1c3252333e8c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b810c10cdb970e8bebbfddce80fdea1"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="samplebuffer_8c.html#a7b810c10cdb970e8bebbfddce80fdea1">samplebuffer_get</a> (<a class="el" href="samplebuffer_8h.html#structsamplebuffer__t">samplebuffer_t</a> *buf, int wpos, int *wlen)</td></tr>
<tr class="memdesc:a7b810c10cdb970e8bebbfddce80fdea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to specific set of samples in the buffer (zero-copy).  <a href="samplebuffer_8c.html#a7b810c10cdb970e8bebbfddce80fdea1">More...</a><br /></td></tr>
<tr class="separator:a7b810c10cdb970e8bebbfddce80fdea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a392b4b826167c5157e983a18493cd4b5"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="samplebuffer_8c.html#a392b4b826167c5157e983a18493cd4b5">samplebuffer_append</a> (<a class="el" href="samplebuffer_8h.html#structsamplebuffer__t">samplebuffer_t</a> *buf, int wlen)</td></tr>
<tr class="memdesc:a392b4b826167c5157e983a18493cd4b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append samples into the buffer (zero-copy).  <a href="samplebuffer_8c.html#a392b4b826167c5157e983a18493cd4b5">More...</a><br /></td></tr>
<tr class="separator:a392b4b826167c5157e983a18493cd4b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af577070f844a4ab787911a647bf51f22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="samplebuffer_8c.html#af577070f844a4ab787911a647bf51f22">samplebuffer_discard</a> (<a class="el" href="samplebuffer_8h.html#structsamplebuffer__t">samplebuffer_t</a> *buf, int wpos)</td></tr>
<tr class="separator:af577070f844a4ab787911a647bf51f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3fe6abffc750a427326ed2490a64067"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="samplebuffer_8c.html#ae3fe6abffc750a427326ed2490a64067">samplebuffer_flush</a> (<a class="el" href="samplebuffer_8h.html#structsamplebuffer__t">samplebuffer_t</a> *buf)</td></tr>
<tr class="separator:ae3fe6abffc750a427326ed2490a64067"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Sample buffer. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a392b4b826167c5157e983a18493cd4b5" name="a392b4b826167c5157e983a18493cd4b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a392b4b826167c5157e983a18493cd4b5">&#9670;&nbsp;</a></span>samplebuffer_append()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * samplebuffer_append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="samplebuffer_8h.html#structsamplebuffer__t">samplebuffer_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>wlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append samples into the buffer (zero-copy). </p>
<p >"wlen" is the number of samples that the caller will append.</p>
<p >The function returns a pointer within the sample buffer where the samples should be written. The samples to be written to physical memory, not just CPU cache, and to enforce this, the function returns a pointer in the uncached segment. Most of the times, we expect samples to be generated or manipulated via RSP/DMA anyway.</p>
<p >The function is meant only to "append" samples, as in add samples that are consecutive within the waveform to the ones already stored in the sample buffer. This is necessary because <a class="el" href="samplebuffer_8h.html#structsamplebuffer__t">samplebuffer_t</a> can only store a single range of samples of the waveform; there is no way to hold two disjoint ranges.</p>
<p >For instance, if the sample buffer currently contains 50 samples starting from position 100 in the waverform, the next call to samplebuffer_append will append samples starting at 150.</p>
<p >If required, samplebuffer_append will discard older samples to make space for the new ones, through <a class="el" href="samplebuffer_8h.html#af577070f844a4ab787911a647bf51f22">samplebuffer_discard</a>. It will only discard samples that come before the "wpos" specified in the last <a class="el" href="samplebuffer_8h.html#a7b810c10cdb970e8bebbfddce80fdea1" title="Get a pointer to specific set of samples in the buffer (zero-copy).">samplebuffer_get</a> call, so to make sure that nothing required for playback is discarded. If there is not enough space in the buffer, it will assert.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Sample buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wlen</td><td>Number of samples to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the area where new samples can be written. </dd></dl>

</div>
</div>
<a id="a4648f973933db48c4aa1c3252333e8c7" name="a4648f973933db48c4aa1c3252333e8c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4648f973933db48c4aa1c3252333e8c7">&#9670;&nbsp;</a></span>samplebuffer_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void samplebuffer_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="samplebuffer_8h.html#structsamplebuffer__t">samplebuffer_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Close the sample buffer.</p>
<p >After calling close, the sample buffer must be initialized again before using it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Sample buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af577070f844a4ab787911a647bf51f22" name="af577070f844a4ab787911a647bf51f22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af577070f844a4ab787911a647bf51f22">&#9670;&nbsp;</a></span>samplebuffer_discard()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void samplebuffer_discard </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="samplebuffer_8h.html#structsamplebuffer__t">samplebuffer_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>wpos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Discard all samples from the buffer that come before a specified absolute waveform position.</p>
<p >This function can be used to discard samples that are not needed anymore in the sample buffer. "wpos" specifies the absolute position of the first sample that should be kept: all samples that come before will be discarded. This function will silently do nothing if there are no samples to discard.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Sample buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wpos</td><td>Absolute waveform position of the first sample that must be kept. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae3fe6abffc750a427326ed2490a64067" name="ae3fe6abffc750a427326ed2490a64067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3fe6abffc750a427326ed2490a64067">&#9670;&nbsp;</a></span>samplebuffer_flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void samplebuffer_flush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="samplebuffer_8h.html#structsamplebuffer__t">samplebuffer_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Flush (reset) the sample buffer to empty status, discarding all samples.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Sample buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b810c10cdb970e8bebbfddce80fdea1" name="a7b810c10cdb970e8bebbfddce80fdea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b810c10cdb970e8bebbfddce80fdea1">&#9670;&nbsp;</a></span>samplebuffer_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * samplebuffer_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="samplebuffer_8h.html#structsamplebuffer__t">samplebuffer_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>wpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>wlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to specific set of samples in the buffer (zero-copy). </p>
<p >"wpos" is the absolute waveform position of the first sample that the caller needs access to. "wlen" is the number of requested samples.</p>
<p >The function returns a pointer within the sample buffer where the samples should be read, and optionally changes "wlen" with the maximum number of samples that can be read. "wlen" is always less or equal to the requested value.</p>
<p >If the samples are available in the buffer, they will be returned immediately. Otherwise, if the samplebuffer has a sample decoder registered via samplebuffer_set_decoder, the decoder "read" function is called once to produce the samples.</p>
<p >If "wlen" is changed with a value less than "wlen", it means that not all samples were available in the buffer and it was not possible to generate more, so the caller should not loop calling this function, but rather use what was obtained and possibly pad with silence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Sample buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wpos</td><td>Absolute waveform position of the first samples to return. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">wlen</td><td>Number of samples to return. After return, it is modified with the actual number of samples that have been returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to samples. </dd></dl>

</div>
</div>
<a id="a09536ab55339204e3392bdced7de21d1" name="a09536ab55339204e3392bdced7de21d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09536ab55339204e3392bdced7de21d1">&#9670;&nbsp;</a></span>samplebuffer_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void samplebuffer_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="samplebuffer_8h.html#structsamplebuffer__t">samplebuffer_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>uncached_mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Initialize the sample buffer by binding it to the specified memory buffer.</p>
<p >The sample buffer is guaranteed to be 8-bytes aligned, so the specified memory buffer must follow this constraint. Moreover, the buffer must be in the uncached segment and not loaded in any CPU cacheline. It is strongly advised to allocate the buffer via <a class="el" href="group__n64sys.html#gaf9f812fb3f12eaee7f5186b893266d3a" title="Allocate a buffer that will be accessed as uncached memory.">malloc_uncached</a>, that takes care of these constraints.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Sample buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uncached_mem</td><td>Memory buffer to use. Must be 8-byte aligned, and in the uncached segment. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of the memory buffer, in bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa16bbcb1683deb8206e06bd9128f9b09" name="aa16bbcb1683deb8206e06bd9128f9b09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa16bbcb1683deb8206e06bd9128f9b09">&#9670;&nbsp;</a></span>samplebuffer_set_bps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void samplebuffer_set_bps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="samplebuffer_8h.html#structsamplebuffer__t">samplebuffer_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the bit width of the samples stored in the buffer. </p>
<p >Valid values for "bps" are 1, 2, or 4: 1 can be used for 8-bit mono samples, 2 for either 8-bit interleaved stereo or 16-bit mono, and 4 for 16-bit interleaved stereo.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Sample buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bps</td><td>Bytes per sample. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae1ed7b8b55c07c6c6a4c6471e94e6145" name="ae1ed7b8b55c07c6c6a4c6471e94e6145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1ed7b8b55c07c6c6a4c6471e94e6145">&#9670;&nbsp;</a></span>samplebuffer_set_waveform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void samplebuffer_set_waveform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="samplebuffer_8h.html#structsamplebuffer__t">samplebuffer_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mixer_8h.html#ab0e995bf04880a3e14f689f48fdb2475">WaveformRead</a>&#160;</td>
          <td class="paramname"><em>read</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Connect a waveform reader callback to this sample buffer. The waveform will be use to produce samples whenever they are required by the mixer as playback progresses.</p>
<p >"read" is the main decoding function, that is invoked to produce a specified number of samples. Normally, the function is invoked by <a class="el" href="samplebuffer_8h.html#a7b810c10cdb970e8bebbfddce80fdea1" title="Get a pointer to specific set of samples in the buffer (zero-copy).">samplebuffer_get</a>, whenever the mixer requests more samples. See <a class="el" href="mixer_8h.html#ab0e995bf04880a3e14f689f48fdb2475" title="Waveform callback function invoked by the mixer to read/generate samples.">WaveformRead</a> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Sample buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">read</td><td>Waveform reading function, that produces samples. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>Opaque context that will be passed to the read function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jul 7 2022 08:55:10 for libdragon by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
