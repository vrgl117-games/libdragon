<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libdragon: rspq.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">libdragon
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">rspq.h File Reference<div class="ingroups"><a class="el" href="group__libdragon.html">libdragon</a> &raquo; <a class="el" href="group__lowlevel.html">Low Level Hardware Interfaces</a> &raquo; <a class="el" href="group__rsp.html">RSP interface</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>RSP Command queue.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;<a class="el" href="rsp_8h_source.html">rsp.h</a>&gt;</code><br />
<code>#include &lt;pputils.h&gt;</code><br />
</div>
<p><a href="rspq_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structrspq__write__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rspq_8h.html#structrspq__write__t">rspq_write_t</a></td></tr>
<tr class="memdesc:structrspq__write__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">A write cursor, returned by <a class="el" href="rspq_8h.html#a7853bba8cbf5773669b9e9ebd7f474cc" title="Begin writing a new command into the RSP queue.">rspq_write_begin</a>.  <a href="rspq_8h.html#structrspq__write__t">More...</a><br /></td></tr>
<tr class="separator:structrspq__write__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a5c35e691b9651ffc302d590a47d47418"><td class="memItemLeft" align="right" valign="top"><a id="a5c35e691b9651ffc302d590a47d47418" name="a5c35e691b9651ffc302d590a47d47418"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>RSPQ_MAX_COMMAND_SIZE</b>&#160;&#160;&#160;63</td></tr>
<tr class="memdesc:a5c35e691b9651ffc302d590a47d47418"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum size of a command (in 32-bit words). <br /></td></tr>
<tr class="separator:a5c35e691b9651ffc302d590a47d47418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3e8eab2e022715528f41c540436c721"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rspq_8h.html#ad3e8eab2e022715528f41c540436c721">RSPQ_MAX_SHORT_COMMAND_SIZE</a>&#160;&#160;&#160;16</td></tr>
<tr class="memdesc:ad3e8eab2e022715528f41c540436c721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum size of a command that it is writable with <a class="el" href="rspq_8h.html#aefec193be7de05f725738beeb3775634" title="Write a new command into the RSP queue.">rspq_write</a> (in 32-bit words).  <a href="rspq_8h.html#ad3e8eab2e022715528f41c540436c721">More...</a><br /></td></tr>
<tr class="separator:ad3e8eab2e022715528f41c540436c721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefec193be7de05f725738beeb3775634"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rspq_8h.html#aefec193be7de05f725738beeb3775634">rspq_write</a>(ovl_id,  cmd_id, ...)</td></tr>
<tr class="memdesc:aefec193be7de05f725738beeb3775634"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a new command into the RSP queue.  <a href="rspq_8h.html#aefec193be7de05f725738beeb3775634">More...</a><br /></td></tr>
<tr class="separator:aefec193be7de05f725738beeb3775634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79c0823905a1e1c371f97b2a0f016996"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rspq_8h.html#a79c0823905a1e1c371f97b2a0f016996">rspq_wait</a>()</td></tr>
<tr class="memdesc:a79c0823905a1e1c371f97b2a0f016996"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until all commands in the queue have been executed by RSP.  <a href="rspq_8h.html#a79c0823905a1e1c371f97b2a0f016996">More...</a><br /></td></tr>
<tr class="separator:a79c0823905a1e1c371f97b2a0f016996"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ad6b3f51acb3629b6fb547e6024c58606"><td class="memItemLeft" align="right" valign="top">typedef struct rspq_block_s&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rspq_8h.html#ad6b3f51acb3629b6fb547e6024c58606">rspq_block_t</a></td></tr>
<tr class="memdesc:ad6b3f51acb3629b6fb547e6024c58606"><td class="mdescLeft">&#160;</td><td class="mdescRight">A preconstructed block of commands.  <a href="rspq_8h.html#ad6b3f51acb3629b6fb547e6024c58606">More...</a><br /></td></tr>
<tr class="separator:ad6b3f51acb3629b6fb547e6024c58606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80d73a81524565e802d89bb14523b1cf"><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rspq_8h.html#a80d73a81524565e802d89bb14523b1cf">rspq_syncpoint_t</a></td></tr>
<tr class="memdesc:a80d73a81524565e802d89bb14523b1cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">A syncpoint in the queue.  <a href="rspq_8h.html#a80d73a81524565e802d89bb14523b1cf">More...</a><br /></td></tr>
<tr class="separator:a80d73a81524565e802d89bb14523b1cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aee149426cb6d86a71812a27b618d59c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rspq_8h.html#aee149426cb6d86a71812a27b618d59c9">rspq_init</a> (void)</td></tr>
<tr class="memdesc:aee149426cb6d86a71812a27b618d59c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the RSPQ library.  <a href="rspq_8h.html#aee149426cb6d86a71812a27b618d59c9">More...</a><br /></td></tr>
<tr class="separator:aee149426cb6d86a71812a27b618d59c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad32f5f99467e9e5e7c7590e34a254d02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rspq_8h.html#ad32f5f99467e9e5e7c7590e34a254d02">rspq_close</a> (void)</td></tr>
<tr class="memdesc:ad32f5f99467e9e5e7c7590e34a254d02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shut down the RSPQ library.  <a href="rspq_8h.html#ad32f5f99467e9e5e7c7590e34a254d02">More...</a><br /></td></tr>
<tr class="separator:ad32f5f99467e9e5e7c7590e34a254d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a072c51be5126cfe5f914aefc52de950a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rspq_8h.html#a072c51be5126cfe5f914aefc52de950a">rspq_overlay_register</a> (<a class="el" href="structrsp__ucode__t.html">rsp_ucode_t</a> *overlay_ucode)</td></tr>
<tr class="memdesc:a072c51be5126cfe5f914aefc52de950a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a rspq overlay into the RSP queue engine.  <a href="rspq_8h.html#a072c51be5126cfe5f914aefc52de950a">More...</a><br /></td></tr>
<tr class="separator:a072c51be5126cfe5f914aefc52de950a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79bb76d8572e721cb4fdd322a6f6cb43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rspq_8h.html#a79bb76d8572e721cb4fdd322a6f6cb43">rspq_overlay_register_static</a> (<a class="el" href="structrsp__ucode__t.html">rsp_ucode_t</a> *overlay_ucode, uint32_t overlay_id)</td></tr>
<tr class="memdesc:a79bb76d8572e721cb4fdd322a6f6cb43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an overlay into the RSP queue engine assigning a static ID to it.  <a href="rspq_8h.html#a79bb76d8572e721cb4fdd322a6f6cb43">More...</a><br /></td></tr>
<tr class="separator:a79bb76d8572e721cb4fdd322a6f6cb43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9b877ae18c66a9258c1b5d04c06e20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rspq_8h.html#a1e9b877ae18c66a9258c1b5d04c06e20">rspq_overlay_unregister</a> (uint32_t overlay_id)</td></tr>
<tr class="memdesc:a1e9b877ae18c66a9258c1b5d04c06e20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister a ucode overlay from the RSP queue engine.  <a href="rspq_8h.html#a1e9b877ae18c66a9258c1b5d04c06e20">More...</a><br /></td></tr>
<tr class="separator:a1e9b877ae18c66a9258c1b5d04c06e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f709a49410891134670ee3a55ff27b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rspq_8h.html#a24f709a49410891134670ee3a55ff27b">rspq_overlay_get_state</a> (<a class="el" href="structrsp__ucode__t.html">rsp_ucode_t</a> *overlay_ucode)</td></tr>
<tr class="memdesc:a24f709a49410891134670ee3a55ff27b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the overlay state (in RDRAM)  <a href="rspq_8h.html#a24f709a49410891134670ee3a55ff27b">More...</a><br /></td></tr>
<tr class="separator:a24f709a49410891134670ee3a55ff27b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7853bba8cbf5773669b9e9ebd7f474cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rspq_8h.html#structrspq__write__t">rspq_write_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rspq_8h.html#a7853bba8cbf5773669b9e9ebd7f474cc">rspq_write_begin</a> (uint32_t ovl_id, uint32_t cmd_id, int size)</td></tr>
<tr class="memdesc:a7853bba8cbf5773669b9e9ebd7f474cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin writing a new command into the RSP queue.  <a href="rspq_8h.html#a7853bba8cbf5773669b9e9ebd7f474cc">More...</a><br /></td></tr>
<tr class="separator:a7853bba8cbf5773669b9e9ebd7f474cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab44674d8d8266f4a515b3fd4c6365b0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rspq_8h.html#ab44674d8d8266f4a515b3fd4c6365b0b">rspq_write_arg</a> (<a class="el" href="rspq_8h.html#structrspq__write__t">rspq_write_t</a> *w, uint32_t value)</td></tr>
<tr class="memdesc:ab44674d8d8266f4a515b3fd4c6365b0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add one argument to the command being enqueued.  <a href="rspq_8h.html#ab44674d8d8266f4a515b3fd4c6365b0b">More...</a><br /></td></tr>
<tr class="separator:ab44674d8d8266f4a515b3fd4c6365b0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f96b9087b04fe6a5f224728ff47701"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rspq_8h.html#a08f96b9087b04fe6a5f224728ff47701">rspq_write_end</a> (<a class="el" href="rspq_8h.html#structrspq__write__t">rspq_write_t</a> *w)</td></tr>
<tr class="memdesc:a08f96b9087b04fe6a5f224728ff47701"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finish enqueuing a command into the queue.  <a href="rspq_8h.html#a08f96b9087b04fe6a5f224728ff47701">More...</a><br /></td></tr>
<tr class="separator:a08f96b9087b04fe6a5f224728ff47701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a115e1839ffd27c126ed6076e2b5de0b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rspq_8h.html#a115e1839ffd27c126ed6076e2b5de0b8">rspq_flush</a> (void)</td></tr>
<tr class="memdesc:a115e1839ffd27c126ed6076e2b5de0b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make sure that RSP starts executing up to the last written command.  <a href="rspq_8h.html#a115e1839ffd27c126ed6076e2b5de0b8">More...</a><br /></td></tr>
<tr class="separator:a115e1839ffd27c126ed6076e2b5de0b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d6fb26b5312a98ad83f758cd7514e6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rspq_8h.html#a80d73a81524565e802d89bb14523b1cf">rspq_syncpoint_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rspq_8h.html#a4d6fb26b5312a98ad83f758cd7514e6e">rspq_syncpoint_new</a> (void)</td></tr>
<tr class="memdesc:a4d6fb26b5312a98ad83f758cd7514e6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a syncpoint in the queue.  <a href="rspq_8h.html#a4d6fb26b5312a98ad83f758cd7514e6e">More...</a><br /></td></tr>
<tr class="separator:a4d6fb26b5312a98ad83f758cd7514e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86e818e81e25912cddbb86672dcd9976"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rspq_8h.html#a86e818e81e25912cddbb86672dcd9976">rspq_syncpoint_check</a> (<a class="el" href="rspq_8h.html#a80d73a81524565e802d89bb14523b1cf">rspq_syncpoint_t</a> sync_id)</td></tr>
<tr class="memdesc:a86e818e81e25912cddbb86672dcd9976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a syncpoint was reached by RSP or not.  <a href="rspq_8h.html#a86e818e81e25912cddbb86672dcd9976">More...</a><br /></td></tr>
<tr class="separator:a86e818e81e25912cddbb86672dcd9976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3aa6ceb175fd56a5969fa01985e1d60"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rspq_8h.html#ac3aa6ceb175fd56a5969fa01985e1d60">rspq_syncpoint_wait</a> (<a class="el" href="rspq_8h.html#a80d73a81524565e802d89bb14523b1cf">rspq_syncpoint_t</a> sync_id)</td></tr>
<tr class="memdesc:ac3aa6ceb175fd56a5969fa01985e1d60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until a syncpoint is reached by RSP.  <a href="rspq_8h.html#ac3aa6ceb175fd56a5969fa01985e1d60">More...</a><br /></td></tr>
<tr class="separator:ac3aa6ceb175fd56a5969fa01985e1d60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f292fc1f7b261f84c55fc356f86acf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rspq_8h.html#a41f292fc1f7b261f84c55fc356f86acf">rspq_block_begin</a> (void)</td></tr>
<tr class="memdesc:a41f292fc1f7b261f84c55fc356f86acf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin creating a new block.  <a href="rspq_8h.html#a41f292fc1f7b261f84c55fc356f86acf">More...</a><br /></td></tr>
<tr class="separator:a41f292fc1f7b261f84c55fc356f86acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81339d69802148a09829d1c6d9a9f9f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rspq_8c.html#structrspq__block__t">rspq_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rspq_8h.html#a81339d69802148a09829d1c6d9a9f9f6">rspq_block_end</a> (void)</td></tr>
<tr class="memdesc:a81339d69802148a09829d1c6d9a9f9f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finish creating a block.  <a href="rspq_8h.html#a81339d69802148a09829d1c6d9a9f9f6">More...</a><br /></td></tr>
<tr class="separator:a81339d69802148a09829d1c6d9a9f9f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad078c001303a1b2153ba99f3184194f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rspq_8h.html#ad078c001303a1b2153ba99f3184194f3">rspq_block_run</a> (<a class="el" href="rspq_8c.html#structrspq__block__t">rspq_block_t</a> *block)</td></tr>
<tr class="memdesc:ad078c001303a1b2153ba99f3184194f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add to the RSP queue a command that runs a block.  <a href="rspq_8h.html#ad078c001303a1b2153ba99f3184194f3">More...</a><br /></td></tr>
<tr class="separator:ad078c001303a1b2153ba99f3184194f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d3fe8768ca839b49421bf08ac5b5c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rspq_8h.html#aa1d3fe8768ca839b49421bf08ac5b5c2">rspq_block_free</a> (<a class="el" href="rspq_8c.html#structrspq__block__t">rspq_block_t</a> *block)</td></tr>
<tr class="memdesc:aa1d3fe8768ca839b49421bf08ac5b5c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a block that is not needed any more.  <a href="rspq_8h.html#aa1d3fe8768ca839b49421bf08ac5b5c2">More...</a><br /></td></tr>
<tr class="separator:aa1d3fe8768ca839b49421bf08ac5b5c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae546104d15d469518ac5fba15521e965"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rspq_8h.html#ae546104d15d469518ac5fba15521e965">rspq_highpri_begin</a> (void)</td></tr>
<tr class="memdesc:ae546104d15d469518ac5fba15521e965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start building a high-priority queue.  <a href="rspq_8h.html#ae546104d15d469518ac5fba15521e965">More...</a><br /></td></tr>
<tr class="separator:ae546104d15d469518ac5fba15521e965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae495b6d8ec49169f05e523fe564f9f4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rspq_8h.html#ae495b6d8ec49169f05e523fe564f9f4b">rspq_highpri_end</a> (void)</td></tr>
<tr class="memdesc:ae495b6d8ec49169f05e523fe564f9f4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finish building the high-priority queue and close it.  <a href="rspq_8h.html#ae495b6d8ec49169f05e523fe564f9f4b">More...</a><br /></td></tr>
<tr class="separator:ae495b6d8ec49169f05e523fe564f9f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a577581d5bf9cfecaa6a1becf3da21d6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rspq_8h.html#a577581d5bf9cfecaa6a1becf3da21d6c">rspq_highpri_sync</a> (void)</td></tr>
<tr class="memdesc:a577581d5bf9cfecaa6a1becf3da21d6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for the RSP to finish processing all high-priority queues.  <a href="rspq_8h.html#a577581d5bf9cfecaa6a1becf3da21d6c">More...</a><br /></td></tr>
<tr class="separator:a577581d5bf9cfecaa6a1becf3da21d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6c56593b83d4bbd5f6229a5a6a7ff18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rspq_8h.html#ae6c56593b83d4bbd5f6229a5a6a7ff18">rspq_noop</a> (void)</td></tr>
<tr class="memdesc:ae6c56593b83d4bbd5f6229a5a6a7ff18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a no-op command in the queue.  <a href="rspq_8h.html#ae6c56593b83d4bbd5f6229a5a6a7ff18">More...</a><br /></td></tr>
<tr class="separator:ae6c56593b83d4bbd5f6229a5a6a7ff18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4048a732f6dc351895e57654a3ea6cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rspq_8h.html#ae4048a732f6dc351895e57654a3ea6cc">rspq_signal</a> (uint32_t signal)</td></tr>
<tr class="memdesc:ae4048a732f6dc351895e57654a3ea6cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a command that sets a signal in SP status.  <a href="rspq_8h.html#ae4048a732f6dc351895e57654a3ea6cc">More...</a><br /></td></tr>
<tr class="separator:ae4048a732f6dc351895e57654a3ea6cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af668e280d3621412dc28cbd59cf31ece"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rspq_8h.html#af668e280d3621412dc28cbd59cf31ece">rspq_dma_to_rdram</a> (void *rdram_addr, uint32_t dmem_addr, uint32_t len, bool is_async)</td></tr>
<tr class="memdesc:af668e280d3621412dc28cbd59cf31ece"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a command to do a DMA transfer from DMEM to RDRAM.  <a href="rspq_8h.html#af668e280d3621412dc28cbd59cf31ece">More...</a><br /></td></tr>
<tr class="separator:af668e280d3621412dc28cbd59cf31ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49e7a85fa93aff13b9818615b5db977"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rspq_8h.html#ac49e7a85fa93aff13b9818615b5db977">rspq_dma_to_dmem</a> (uint32_t dmem_addr, void *rdram_addr, uint32_t len, bool is_async)</td></tr>
<tr class="memdesc:ac49e7a85fa93aff13b9818615b5db977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a command to do a DMA transfer from RDRAM to DMEM.  <a href="rspq_8h.html#ac49e7a85fa93aff13b9818615b5db977">More...</a><br /></td></tr>
<tr class="separator:ac49e7a85fa93aff13b9818615b5db977"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >RSP Command queue. </p>
<p >The RSP command queue library provides the basic infrastructure to allow a very efficient use of the RSP coprocessor. On the CPU side, it implements an API to enqueue "commands" to be executed by RSP into a ring buffer, that is concurrently consumed by RSP in background. On the RSP side, it provides the core loop that reads and execute the queue prepared by the CPU, and an infrastructure to write "RSP overlays", that is libraries that plug upon the RSP command queue to perform actual RSP jobs (eg: 3D graphics, audio, etc.).</p>
<p >The library is extremely efficient. It is designed for very high throughput and low latency, as the RSP pulls by the queue concurrently as the CPU fills it. Through some complex synchronization paradigms, both CPU and RSP run fully lockless, that is never need to explicitly synchronize with each other (unless requested by the user). The CPU can keep filling the queue and must only wait for RSP in case the queue becomes full; on the other side, the RSP can keep processing the queue without ever talking to the CPU.</p>
<p >The library has been designed to be able to enqueue thousands of RSP commands per frame without its overhead to be measurable, which should be more than enough for most use cases.</p>
<p >This documentation describes the API of the queue, and how to use it. For details on how it is implemented, see the comments in <a class="el" href="rspq_8c.html" title="RSP Command queue.">rspq.c</a>.</p>
<h2><a class="anchor" id="autotoc_md20"></a>
Commands</h2>
<p >Each command in the queue is made by one or more 32-bit words (up to <a class="el" href="rspq_8h.html#a5c35e691b9651ffc302d590a47d47418" title="Maximum size of a command (in 32-bit words).">RSPQ_MAX_COMMAND_SIZE</a>). The MSB of the first word is the command ID. The higher 4 bits are called the "overlay ID" and identify the overlay that is able to execute the command; the lower 4 bits are the command index, which identify the command within the overlay. For instance, command ID 0x37 is command index 7 in overlay 3.</p>
<p >As the RSP executes the queue, it will parse the command ID and dispatch it for execution. When required, the RSP will automatically load the RSP overlay needed to execute a command. In the previous example, the RSP will load into IMEM/DMEM overlay 3 (unless it was already loaded) and then dispatch command 7 to it.</p>
<h2><a class="anchor" id="autotoc_md21"></a>
Higher-level libraries and overlays</h2>
<p >Higher-level libraries that come with their RSP ucode can be designed to use the RSP command queue to efficiently coexist with all other RSP libraries provided by libdragon. In fact, by using the overlay mechanism, each library can obtain its own overlay ID, and enqueue commands to be executed by the RSP through the same unique queue. Overlay IDs are allocated dynamically by rspq in registration order, to avoid conflicts between libraries.</p>
<p >End-users can then use all these libraries at the same time, without having to arrange for complex RSP synchronization, asynchronous execution or plan for efficient context switching. In fact, they don't even need to be aware that the libraries are using the RSP. Through the unified command queue, the RSP can be used efficiently and effortlessly without idle time, nor wasting CPU cycles waiting for completion of a task before switching to another one.</p>
<p >Higher-level libraries that are designed to use the RSP command queue must:</p>
<ul>
<li>Call <a class="el" href="rspq_8h.html#aee149426cb6d86a71812a27b618d59c9" title="Initialize the RSPQ library.">rspq_init</a> at initialization. The function can be called multiple times by different libraries, with no side-effect.</li>
<li>Call <a class="el" href="rspq_8h.html#a072c51be5126cfe5f914aefc52de950a" title="Register a rspq overlay into the RSP queue engine.">rspq_overlay_register</a> to register a <a class="el" href="structrsp__ucode__t.html" title="RSP ucode definition.">rsp_ucode_t</a> as RSP command queue overlay, obtaining an overlay ID to use.</li>
<li>Provide higher-level APIs that, when required, call <a class="el" href="rspq_8h.html#aefec193be7de05f725738beeb3775634" title="Write a new command into the RSP queue.">rspq_write</a> and <a class="el" href="rspq_8h.html#a115e1839ffd27c126ed6076e2b5de0b8" title="Make sure that RSP starts executing up to the last written command.">rspq_flush</a> to enqueue commands for the RSP. For instance, a matrix library might provide a "matrix_mult" function that internally calls <a class="el" href="rspq_8h.html#aefec193be7de05f725738beeb3775634" title="Write a new command into the RSP queue.">rspq_write</a> to enqueue a command for the RSP to perform the calculation.</li>
</ul>
<p >Normally, end-users will not need to manually enqueue commands in the RSP queue: they should only call higher-level APIs which internally do that.</p>
<h2><a class="anchor" id="autotoc_md22"></a>
Blocks</h2>
<p >A block (<a class="el" href="rspq_8c.html#structrspq__block__t" title="A pre-built block of commands.">rspq_block_t</a>) is a prerecorded sequence of RSP commands that can be played back. Blocks can be created via <a class="el" href="rspq_8h.html#a41f292fc1f7b261f84c55fc356f86acf" title="Begin creating a new block.">rspq_block_begin</a> / <a class="el" href="rspq_8h.html#a81339d69802148a09829d1c6d9a9f9f6" title="Finish creating a block.">rspq_block_end</a>, and then executed by <a class="el" href="rspq_8h.html#ad078c001303a1b2153ba99f3184194f3" title="Add to the RSP queue a command that runs a block.">rspq_block_run</a>. It is also possible to do nested calls (a block can call another block), up to 8 levels deep.</p>
<p >A block is very efficient to run because it is played back by the RSP itself. The CPU just enqueues a single command that "calls" the block. It is thus much faster than enqueuing the same commands every frame.</p>
<p >Blocks can be used by higher-level libraries as an internal tool to efficiently drive the RSP (without having to repeat common sequence of commands), or they can be used by end-users to record and replay batch of commands, similar to OpenGL 1.x display lists.</p>
<p >Notice that this library does not support static (compile-time) blocks. Blocks must always be created at runtime once (eg: at init time) before being used.</p>
<h2><a class="anchor" id="autotoc_md23"></a>
Syncpoints</h2>
<p >The RSP command queue is designed to be fully lockless, but sometimes it is required to know when the RSP has actually executed an enqueued command or not (eg: to use its result). To do so, this library offers a synchronization primitive called "syncpoint" (<a class="el" href="rspq_8h.html#a80d73a81524565e802d89bb14523b1cf" title="A syncpoint in the queue.">rspq_syncpoint_t</a>). A syncpoint can be created via <a class="el" href="rspq_8h.html#a4d6fb26b5312a98ad83f758cd7514e6e" title="Create a syncpoint in the queue.">rspq_syncpoint_new</a> and records the current writing position in the queue. It is then possible to call <a class="el" href="rspq_8h.html#a86e818e81e25912cddbb86672dcd9976" title="Check whether a syncpoint was reached by RSP or not.">rspq_syncpoint_check</a> to check whether the RSP has reached that position, or <a class="el" href="rspq_8h.html#ac3aa6ceb175fd56a5969fa01985e1d60" title="Wait until a syncpoint is reached by RSP.">rspq_syncpoint_wait</a> to wait for the RSP to reach that position.</p>
<p >Syncpoints are implemented using RSP interrupts, so their overhead is small but still measurable. They should not be abused.</p>
<h2><a class="anchor" id="autotoc_md24"></a>
High-priority queue</h2>
<p >This library offers a mechanism to preempt the execution of RSP to give priority to very urgent tasks: the high-priority queue. Since the moment a high-priority queue is created via <a class="el" href="rspq_8h.html#ae546104d15d469518ac5fba15521e965" title="Start building a high-priority queue.">rspq_highpri_begin</a>, the RSP immediately suspends execution of the command queue, and switches to the high-priority queue, waiting for commands. All commands added via standard APIs (<a class="el" href="rspq_8h.html#aefec193be7de05f725738beeb3775634" title="Write a new command into the RSP queue.">rspq_write</a>) are then directed to the high-priority queue, until <a class="el" href="rspq_8h.html#ae495b6d8ec49169f05e523fe564f9f4b" title="Finish building the high-priority queue and close it.">rspq_highpri_end</a> is called. Once the RSP has finished executing all the commands enqueue in the high-priority queue, it resumes execution of the standard queue.</p>
<p >The net effect is that commands enqueued in the high-priority queue are executed right away by the RSP, irrespective to whatever was currently enqueued in the standard queue. This can be useful for running tasks that require immediate execution, like for instance audio processing.</p>
<p >If required, it is possible to call <a class="el" href="rspq_8h.html#a577581d5bf9cfecaa6a1becf3da21d6c" title="Wait for the RSP to finish processing all high-priority queues.">rspq_highpri_sync</a> to wait for the high-priority queue to be fully executed.</p>
<p >Notice that the RSP cannot be fully preempted, so switching to the high-priority queue can only happen after a command has finished execution (before starting the following one). This can have an effect on latency if a single command has a very long execution time; RSP overlays should in general prefer providing smaller, faster commands.</p>
<p >This feature should normally not be used by end-users, but by libraries in which a very low latency of RSP execution is paramount to their workings. </p>
</div><hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structrspq__write__t" id="structrspq__write__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structrspq__write__t">&#9670;&nbsp;</a></span>rspq_write_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct rspq_write_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p >A write cursor, returned by <a class="el" href="rspq_8h.html#a7853bba8cbf5773669b9e9ebd7f474cc" title="Begin writing a new command into the RSP queue.">rspq_write_begin</a>. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a10f75a17ee9020073032057f2c088d59" name="a10f75a17ee9020073032057f2c088d59"></a>volatile uint32_t *</td>
<td class="fieldname">
first</td>
<td class="fielddoc">
pointer to the first word of the command </td></tr>
<tr><td class="fieldtype">
<a id="a157026e64a3eef732005c716ff7752cb" name="a157026e64a3eef732005c716ff7752cb"></a>uint32_t</td>
<td class="fieldname">
first_word</td>
<td class="fielddoc">
value that will be written as first word </td></tr>
<tr><td class="fieldtype">
<a id="a86af89ac420fb4ad8c2a71416becdef8" name="a86af89ac420fb4ad8c2a71416becdef8"></a>bool</td>
<td class="fieldname">
is_first</td>
<td class="fielddoc">
true if we are waiting for the first argument word </td></tr>
<tr><td class="fieldtype">
<a id="a168e98244814397e70942dded68c94f1" name="a168e98244814397e70942dded68c94f1"></a>volatile uint32_t *</td>
<td class="fieldname">
pointer</td>
<td class="fielddoc">
current pointer into the RSP queue </td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ad3e8eab2e022715528f41c540436c721" name="ad3e8eab2e022715528f41c540436c721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3e8eab2e022715528f41c540436c721">&#9670;&nbsp;</a></span>RSPQ_MAX_SHORT_COMMAND_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RSPQ_MAX_SHORT_COMMAND_SIZE&#160;&#160;&#160;16</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum size of a command that it is writable with <a class="el" href="rspq_8h.html#aefec193be7de05f725738beeb3775634" title="Write a new command into the RSP queue.">rspq_write</a> (in 32-bit words). </p>
<p >For larger commands, use <a class="el" href="rspq_8h.html#a7853bba8cbf5773669b9e9ebd7f474cc" title="Begin writing a new command into the RSP queue.">rspq_write_begin</a> + <a class="el" href="rspq_8h.html#ab44674d8d8266f4a515b3fd4c6365b0b" title="Add one argument to the command being enqueued.">rspq_write_arg</a> + <a class="el" href="rspq_8h.html#a08f96b9087b04fe6a5f224728ff47701" title="Finish enqueuing a command into the queue.">rspq_write_end</a>. </p>

</div>
</div>
<a id="a79c0823905a1e1c371f97b2a0f016996" name="a79c0823905a1e1c371f97b2a0f016996"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79c0823905a1e1c371f97b2a0f016996">&#9670;&nbsp;</a></span>rspq_wait</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rspq_wait</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    ({ \</div>
<div class="line">    rspq_syncpoint_wait(<a class="code hl_function" href="rspq_8h.html#a4d6fb26b5312a98ad83f758cd7514e6e">rspq_syncpoint_new</a>()); \</div>
<div class="line">})</div>
<div class="ttc" id="arspq_8h_html_a4d6fb26b5312a98ad83f758cd7514e6e"><div class="ttname"><a href="rspq_8h.html#a4d6fb26b5312a98ad83f758cd7514e6e">rspq_syncpoint_new</a></div><div class="ttdeci">rspq_syncpoint_t rspq_syncpoint_new(void)</div><div class="ttdoc">Create a syncpoint in the queue.</div><div class="ttdef"><b>Definition:</b> rspq.c:1224</div></div>
</div><!-- fragment -->
<p>Wait until all commands in the queue have been executed by RSP. </p>
<p >This function blocks until all commands present in the queue have been executed by the RSP and the RSP is idle.</p>
<p >This function exists mostly for debugging purposes. Calling this function is not necessary, as the CPU can continue adding commands to the queue while the RSP is running them. If you need to synchronize between RSP and CPU (eg: to access data that was processed by RSP) prefer using <a class="el" href="rspq_8h.html#a4d6fb26b5312a98ad83f758cd7514e6e" title="Create a syncpoint in the queue.">rspq_syncpoint_new</a> / <a class="el" href="rspq_8h.html#ac3aa6ceb175fd56a5969fa01985e1d60" title="Wait until a syncpoint is reached by RSP.">rspq_syncpoint_wait</a> which allows for more granular synchronization. </p>

</div>
</div>
<a id="aefec193be7de05f725738beeb3775634" name="aefec193be7de05f725738beeb3775634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefec193be7de05f725738beeb3775634">&#9670;&nbsp;</a></span>rspq_write</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rspq_write</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ovl_id, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cmd_id, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a new command into the RSP queue. </p>
<p >This macro is the main entry point to add a command to the RSP queue. It can be used as a variadic argument function, in which the first argument is the overlay ID, the second argument is the command index within the overlay, and the other arguments are the command arguments (additional 32-bit words).</p>
<div class="fragment"><div class="line"><span class="comment">// This example adds to the queue a command called CMD_SPRITE with </span></div>
<div class="line"><span class="comment">// index 0xA, with its arguments, for a total of three words. The overlay</span></div>
<div class="line"><span class="comment">// was previously registered via #rspq_register_overlay.</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define CMD_SPRITE  0xA</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="rspq_8h.html#aefec193be7de05f725738beeb3775634">rspq_write</a>(gfx_overlay_id, CMD_SPRITE,</div>
<div class="line">           sprite_num, </div>
<div class="line">           (x0 &lt;&lt; 16) | y0,</div>
<div class="line">           (x1 &lt;&lt; 16) | y1);</div>
<div class="ttc" id="arspq_8h_html_aefec193be7de05f725738beeb3775634"><div class="ttname"><a href="rspq_8h.html#aefec193be7de05f725738beeb3775634">rspq_write</a></div><div class="ttdeci">#define rspq_write(ovl_id, cmd_id,...)</div><div class="ttdoc">Write a new command into the RSP queue.</div><div class="ttdef"><b>Definition:</b> rspq.h:366</div></div>
</div><!-- fragment --><p >As explained in the top-level documentation, the overlay ID (4 bits) and the command index (4 bits) are composed to form the command ID, and are stored in the most significant byte of the first word. So, the first command argument word, if provided, must have the upper MSB empty, to leave space for the command ID itself.</p>
<p >For instance, assuming the overlay ID for an overlay called "gfx" is 1, <code><a class="el" href="rspq_8h.html#aefec193be7de05f725738beeb3775634" title="Write a new command into the RSP queue.">rspq_write(gfx_id, 0x2, 0x00FF2233)</a></code> is a correct call, which writes <code>0x12FF2233</code> into the RSP queue; it will invoke command #2 in overlay with ID 0x1, and the first word contains other 24 bits of arguments that will be parsed by the RSP code. Instead, <code><a class="el" href="rspq_8h.html#aefec193be7de05f725738beeb3775634" title="Write a new command into the RSP queue.">rspq_write(gfx_id, 0x2, 0x11FF2233)</a></code> is an invalid call because the MSB of the first word is non-zero, and thus the highest byte "0x11" would clash with the overlay ID and command index.</p>
<p ><code><a class="el" href="rspq_8h.html#aefec193be7de05f725738beeb3775634" title="Write a new command into the RSP queue.">rspq_write(gfx_id, 0x2)</a></code> is a valid call, and equivalent to <code><a class="el" href="rspq_8h.html#aefec193be7de05f725738beeb3775634" title="Write a new command into the RSP queue.">rspq_write(gfx_id, 0x2, 0x0)</a></code>. It will write <code>0x12000000</code> in the queue.</p>
<p >Notice that after a call to <a class="el" href="rspq_8h.html#aefec193be7de05f725738beeb3775634" title="Write a new command into the RSP queue.">rspq_write</a>, the command might or might not get executed by the RSP, depending on timing. If you want to make sure that the command will be executed, use <a class="el" href="rspq_8h.html#a115e1839ffd27c126ed6076e2b5de0b8" title="Make sure that RSP starts executing up to the last written command.">rspq_flush</a>. You can call <a class="el" href="rspq_8h.html#a115e1839ffd27c126ed6076e2b5de0b8" title="Make sure that RSP starts executing up to the last written command.">rspq_flush</a> after you have finished writing a batch of related commands. See <a class="el" href="rspq_8h.html#a115e1839ffd27c126ed6076e2b5de0b8" title="Make sure that RSP starts executing up to the last written command.">rspq_flush</a> documentation for more information.</p>
<p ><a class="el" href="rspq_8h.html#aefec193be7de05f725738beeb3775634" title="Write a new command into the RSP queue.">rspq_write</a> allows to write a full command with a single call, which is normally the easiest way to do it; it supports up to 16 argument words. In case it is needed to assemble larger commands, see <a class="el" href="rspq_8h.html#a7853bba8cbf5773669b9e9ebd7f474cc" title="Begin writing a new command into the RSP queue.">rspq_write_begin</a> for an alternative API.</p>
<dl class="section note"><dt>Note</dt><dd>Each command can be up to <a class="el" href="rspq_8h.html#ad3e8eab2e022715528f41c540436c721" title="Maximum size of a command that it is writable with rspq_write (in 32-bit words).">RSPQ_MAX_SHORT_COMMAND_SIZE</a> 32-bit words.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ovl_id</td><td>The overlay ID of the command to enqueue. Notice that this must be a value preshifted by 28, as returned by <a class="el" href="rspq_8h.html#a072c51be5126cfe5f914aefc52de950a" title="Register a rspq overlay into the RSP queue engine.">rspq_overlay_register</a>. </td></tr>
    <tr><td class="paramname">cmd_id</td><td>Index of the command to call, within the overlay. </td></tr>
    <tr><td class="paramname">...</td><td>Optional arguments for the command</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rspq_8h.html#a072c51be5126cfe5f914aefc52de950a" title="Register a rspq overlay into the RSP queue engine.">rspq_overlay_register</a> </dd>
<dd>
<a class="el" href="rspq_8h.html#a115e1839ffd27c126ed6076e2b5de0b8" title="Make sure that RSP starts executing up to the last written command.">rspq_flush</a> </dd>
<dd>
<a class="el" href="rspq_8h.html#a7853bba8cbf5773669b9e9ebd7f474cc" title="Begin writing a new command into the RSP queue.">rspq_write_begin</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ad6b3f51acb3629b6fb547e6024c58606" name="ad6b3f51acb3629b6fb547e6024c58606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6b3f51acb3629b6fb547e6024c58606">&#9670;&nbsp;</a></span>rspq_block_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct rspq_block_s <a class="el" href="rspq_8c.html#structrspq__block__t">rspq_block_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A preconstructed block of commands. </p>
<p >To improve performance of execution of sequences of commands, it is possible to create a "block". A block is a fixed set of commands that is created once and executed multiple times.</p>
<p >To create a block, use <a class="el" href="rspq_8h.html#a41f292fc1f7b261f84c55fc356f86acf" title="Begin creating a new block.">rspq_block_begin</a> and <a class="el" href="rspq_8h.html#a81339d69802148a09829d1c6d9a9f9f6" title="Finish creating a block.">rspq_block_end</a>. After creation, you can use <a class="el" href="rspq_8h.html#ad078c001303a1b2153ba99f3184194f3" title="Add to the RSP queue a command that runs a block.">rspq_block_run</a> at any point to run it. If you do not need the block anymore, use <a class="el" href="rspq_8h.html#aa1d3fe8768ca839b49421bf08ac5b5c2" title="Free a block that is not needed any more.">rspq_block_free</a> to dispose it. </p>

</div>
</div>
<a id="a80d73a81524565e802d89bb14523b1cf" name="a80d73a81524565e802d89bb14523b1cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80d73a81524565e802d89bb14523b1cf">&#9670;&nbsp;</a></span>rspq_syncpoint_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int <a class="el" href="rspq_8h.html#a80d73a81524565e802d89bb14523b1cf">rspq_syncpoint_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A syncpoint in the queue. </p>
<p >A syncpoint can be thought of as a pointer to a position in the command queue. After creation, it is possible to later check whether the RSP has reached that position or not.</p>
<p >To create a syncpoint, use <a class="el" href="rspq_8h.html#a4d6fb26b5312a98ad83f758cd7514e6e" title="Create a syncpoint in the queue.">rspq_syncpoint_new</a> that returns a syncpoint that references the current position. Call <a class="el" href="rspq_8h.html#a86e818e81e25912cddbb86672dcd9976" title="Check whether a syncpoint was reached by RSP or not.">rspq_syncpoint_check</a> or <a class="el" href="rspq_8h.html#ac3aa6ceb175fd56a5969fa01985e1d60" title="Wait until a syncpoint is reached by RSP.">rspq_syncpoint_wait</a> to respectively do a single check or block waiting for the syncpoint to be reached by RSP.</p>
<p >Syncpoints are implemented using interrupts, so they have a light but non trivial overhead. Do not abuse them. For instance, it is reasonable to use tens of syncpoints per frame, but not hundreds or thousands of them.</p>
<dl class="section note"><dt>Note</dt><dd>A valid syncpoint is an integer greater than 0. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a41f292fc1f7b261f84c55fc356f86acf" name="a41f292fc1f7b261f84c55fc356f86acf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41f292fc1f7b261f84c55fc356f86acf">&#9670;&nbsp;</a></span>rspq_block_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rspq_block_begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Begin creating a new block. </p>
<p >This function begins writing a command block (see <a class="el" href="rspq_8c.html#structrspq__block__t" title="A pre-built block of commands.">rspq_block_t</a>). While a block is being written, all calls to <a class="el" href="rspq_8h.html#aefec193be7de05f725738beeb3775634" title="Write a new command into the RSP queue.">rspq_write</a> will record the commands into the block, without actually scheduling them for execution. Use <a class="el" href="rspq_8h.html#a81339d69802148a09829d1c6d9a9f9f6" title="Finish creating a block.">rspq_block_end</a> to close the block and get a reference to it.</p>
<p >Only one block at a time can be created. Calling <a class="el" href="rspq_8h.html#a41f292fc1f7b261f84c55fc356f86acf" title="Begin creating a new block.">rspq_block_begin</a> twice (without any intervening <a class="el" href="rspq_8h.html#a81339d69802148a09829d1c6d9a9f9f6" title="Finish creating a block.">rspq_block_end</a>) will cause an assert.</p>
<p >During block creation, the RSP will keep running as usual and execute commands that have been already added to the queue.</p>
<dl class="section note"><dt>Note</dt><dd>Calls to <a class="el" href="rspq_8h.html#a115e1839ffd27c126ed6076e2b5de0b8" title="Make sure that RSP starts executing up to the last written command.">rspq_flush</a> are ignored during block creation, as the RSP is not going to execute the block commands anyway. </dd></dl>

</div>
</div>
<a id="a81339d69802148a09829d1c6d9a9f9f6" name="a81339d69802148a09829d1c6d9a9f9f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81339d69802148a09829d1c6d9a9f9f6">&#9670;&nbsp;</a></span>rspq_block_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rspq_8c.html#structrspq__block__t">rspq_block_t</a> * rspq_block_end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finish creating a block. </p>
<p >This function completes a block and returns a reference to it (see <a class="el" href="rspq_8c.html#structrspq__block__t" title="A pre-built block of commands.">rspq_block_t</a>). After this function is called, all subsequent <a class="el" href="rspq_8h.html#aefec193be7de05f725738beeb3775634" title="Write a new command into the RSP queue.">rspq_write</a> will resume working as usual: they will add commands to the queue for immediate RSP execution.</p>
<p >To run the created block, use <a class="el" href="rspq_8h.html#ad078c001303a1b2153ba99f3184194f3" title="Add to the RSP queue a command that runs a block.">rspq_block_run</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the just created block</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rspq_8h.html#a41f292fc1f7b261f84c55fc356f86acf" title="Begin creating a new block.">rspq_block_begin</a> </dd>
<dd>
<a class="el" href="rspq_8h.html#ad078c001303a1b2153ba99f3184194f3" title="Add to the RSP queue a command that runs a block.">rspq_block_run</a> </dd></dl>

</div>
</div>
<a id="aa1d3fe8768ca839b49421bf08ac5b5c2" name="aa1d3fe8768ca839b49421bf08ac5b5c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1d3fe8768ca839b49421bf08ac5b5c2">&#9670;&nbsp;</a></span>rspq_block_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rspq_block_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rspq_8c.html#structrspq__block__t">rspq_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a block that is not needed any more. </p>
<p >After calling this function, the block is invalid and must not be called anymore.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the block was being called by other blocks, these other blocks become invalid and will make the RSP crash if called. Make sure that freeing a block is only done when no other blocks reference it. </dd></dl>

</div>
</div>
<a id="ad078c001303a1b2153ba99f3184194f3" name="ad078c001303a1b2153ba99f3184194f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad078c001303a1b2153ba99f3184194f3">&#9670;&nbsp;</a></span>rspq_block_run()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rspq_block_run </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rspq_8c.html#structrspq__block__t">rspq_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add to the RSP queue a command that runs a block. </p>
<p >This function runs a block that was previously created via <a class="el" href="rspq_8h.html#a41f292fc1f7b261f84c55fc356f86acf" title="Begin creating a new block.">rspq_block_begin</a> and <a class="el" href="rspq_8h.html#a81339d69802148a09829d1c6d9a9f9f6" title="Finish creating a block.">rspq_block_end</a>. It schedules a special command in the queue that will run the block, so that execution of the block will happen in order relative to other commands in the queue.</p>
<p >Blocks can call other blocks. For instance, if a block A has been fully created, it is possible to call <code>rspq_block_run(A)</code> at any point during the creation of a second block B; this means that B will contain the special command that will call A.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block that must be run</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The maximum depth of nested block calls is 8. </dd></dl>

</div>
</div>
<a id="ad32f5f99467e9e5e7c7590e34a254d02" name="ad32f5f99467e9e5e7c7590e34a254d02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad32f5f99467e9e5e7c7590e34a254d02">&#9670;&nbsp;</a></span>rspq_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rspq_close </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shut down the RSPQ library. </p>
<p >This is mainly used for testing. </p>

</div>
</div>
<a id="ac49e7a85fa93aff13b9818615b5db977" name="ac49e7a85fa93aff13b9818615b5db977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac49e7a85fa93aff13b9818615b5db977">&#9670;&nbsp;</a></span>rspq_dma_to_dmem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rspq_dma_to_dmem </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dmem_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>rdram_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_async</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enqueue a command to do a DMA transfer from RDRAM to DMEM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dmem_addr</td><td>The DMEM address (destination, must be aligned to 8) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">rdram_addr</td><td>The RDRAM address (source, must be aligned to 8) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of bytes to transfer (must be multiple of 8) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_async</td><td>If true, the RSP does not wait for DMA completion and processes the next command as the DMA is in progress. If false, the RSP waits until the transfer is finished before processing the next command.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The argument is_async refers to the RSP only. From the CPU standpoint, this function is always asynchronous as it just adds a command to the queue. </dd></dl>

</div>
</div>
<a id="af668e280d3621412dc28cbd59cf31ece" name="af668e280d3621412dc28cbd59cf31ece"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af668e280d3621412dc28cbd59cf31ece">&#9670;&nbsp;</a></span>rspq_dma_to_rdram()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rspq_dma_to_rdram </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>rdram_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dmem_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_async</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enqueue a command to do a DMA transfer from DMEM to RDRAM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">rdram_addr</td><td>The RDRAM address (destination, must be aligned to 8) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmem_addr</td><td>The DMEM address (source, must be aligned to 8) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of bytes to transfer (must be multiple of 8) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_async</td><td>If true, the RSP does not wait for DMA completion and processes the next command as the DMA is in progress. If false, the RSP waits until the transfer is finished before processing the next command.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The argument is_async refers to the RSP only. From the CPU standpoint, this function is always asynchronous as it just adds a command to the queue. </dd></dl>

</div>
</div>
<a id="a115e1839ffd27c126ed6076e2b5de0b8" name="a115e1839ffd27c126ed6076e2b5de0b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a115e1839ffd27c126ed6076e2b5de0b8">&#9670;&nbsp;</a></span>rspq_flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rspq_flush </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make sure that RSP starts executing up to the last written command. </p>
<p >RSP processes the command queue asynchronously as it is being written. If it catches up with the CPU, it halts itself and waits for the CPU to notify that more commands are available. On the contrary, if the RSP lags behind it might keep executing commands as they are written without ever sleeping. So in general, at any given moment the RSP could be crunching commands or sleeping waiting to be notified that more commands are available.</p>
<p >This means that writing a command via <a class="el" href="rspq_8h.html#aefec193be7de05f725738beeb3775634" title="Write a new command into the RSP queue.">rspq_write</a> is not enough to make sure it is executed; depending on timing and batching performed by RSP, it might either be executed automatically or not. <a class="el" href="rspq_8h.html#a115e1839ffd27c126ed6076e2b5de0b8" title="Make sure that RSP starts executing up to the last written command.">rspq_flush</a> makes sure that the RSP will see it and execute it.</p>
<p >This function does not block: it just make sure that the RSP will run the full command queue written until now. If you need to actively wait until the last written command has been executed, use <a class="el" href="rspq_8h.html#a79c0823905a1e1c371f97b2a0f016996" title="Wait until all commands in the queue have been executed by RSP.">rspq_wait</a>.</p>
<p >It is suggested to call rspq_flush every time a new "batch" of commands has been written. In general, it is not a problem to call it often because it is very very fast (takes only ~20 cycles). For instance, it can be called after every rspq_write without many worries, but if you know that you are going to write a number of subsequent commands in straight line code, you can postpone the call to <a class="el" href="rspq_8h.html#a115e1839ffd27c126ed6076e2b5de0b8" title="Make sure that RSP starts executing up to the last written command.">rspq_flush</a> after the whole sequence has been written.</p>
<div class="fragment"><div class="line">   <span class="comment">// This example shows some code configuring the lights for a scene.</span></div>
<div class="line">   <span class="comment">// The command in this sample is called CMD_SET_LIGHT and requires</span></div>
<div class="line">   <span class="comment">// a light index and the RGB colors for the list to update.</span></div>
<div class="line">uint32_t gfx_overlay_id;   </div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">   #define CMD_SET_LIGHT  0x7</span></div>
<div class="line"> </div>
<div class="line">   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;MAX_LIGHTS; i++) {</div>
<div class="line">       <a class="code hl_define" href="rspq_8h.html#aefec193be7de05f725738beeb3775634">rspq_write</a>(gfx_overlay_id, CMD_SET_LIGHT, i,</div>
<div class="line">           (lights[i].r &lt;&lt; 16) | (lights[i].g &lt;&lt; 8) | lights[i].b);</div>
<div class="line">   }</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// After enqueuing multiple commands, it is sufficient</span></div>
<div class="line">   <span class="comment">// to call rspq_flush once to make sure the RSP runs them (in case</span></div>
<div class="line">   <span class="comment">// it was idling).</span></div>
<div class="line">   <a class="code hl_function" href="rspq_8c.html#a115e1839ffd27c126ed6076e2b5de0b8">rspq_flush</a>();</div>
<div class="ttc" id="arspq_8c_html_a115e1839ffd27c126ed6076e2b5de0b8"><div class="ttname"><a href="rspq_8c.html#a115e1839ffd27c126ed6076e2b5de0b8">rspq_flush</a></div><div class="ttdeci">void rspq_flush(void)</div><div class="ttdoc">Make sure that RSP starts executing up to the last written command.</div><div class="ttdef"><b>Definition:</b> rspq.c:1052</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This is an experimental API. In the future, it might become a no-op, and flushing could happen automatically at every <a class="el" href="rspq_8h.html#aefec193be7de05f725738beeb3775634" title="Write a new command into the RSP queue.">rspq_write</a>. We are keeping it separate from <a class="el" href="rspq_8h.html#aefec193be7de05f725738beeb3775634" title="Write a new command into the RSP queue.">rspq_write</a> while experimenting more with the RSPQ API.</dd>
<dd>
This function is a no-op if it is called while a block is being recorded (see <a class="el" href="rspq_8h.html#a41f292fc1f7b261f84c55fc356f86acf" title="Begin creating a new block.">rspq_block_begin</a> / <a class="el" href="rspq_8h.html#a81339d69802148a09829d1c6d9a9f9f6" title="Finish creating a block.">rspq_block_end</a>). This means calling this function in a block recording context will not guarantee the execution of commands that were queued prior to starting the block. </dd></dl>

</div>
</div>
<a id="ae546104d15d469518ac5fba15521e965" name="ae546104d15d469518ac5fba15521e965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae546104d15d469518ac5fba15521e965">&#9670;&nbsp;</a></span>rspq_highpri_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rspq_highpri_begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start building a high-priority queue. </p>
<p >This function enters a special mode in which a high-priority queue is activated and can be filled with commands. After this function has been called, all commands will be put in the high-priority queue, until <a class="el" href="rspq_8h.html#ae495b6d8ec49169f05e523fe564f9f4b" title="Finish building the high-priority queue and close it.">rspq_highpri_end</a> is called.</p>
<p >The RSP will start processing the high-priority queue almost instantly (as soon as the current command is done), pausing the normal queue. This will also happen while the high-priority queue is being built, to achieve the lowest possible latency. When the RSP finishes processing the high priority queue (after <a class="el" href="rspq_8h.html#ae495b6d8ec49169f05e523fe564f9f4b" title="Finish building the high-priority queue and close it.">rspq_highpri_end</a> closes it), it resumes processing the normal queue from the exact point that was left.</p>
<p >The goal of the high-priority queue is to either schedule latency-sensitive commands like audio processing, or to schedule immediate RSP calculations that should be performed right away, just like they were preempting what the RSP is currently doing.</p>
<p >It is possible to create multiple high-priority queues by calling <a class="el" href="rspq_8h.html#ae546104d15d469518ac5fba15521e965" title="Start building a high-priority queue.">rspq_highpri_begin</a> / <a class="el" href="rspq_8h.html#ae495b6d8ec49169f05e523fe564f9f4b" title="Finish building the high-priority queue and close it.">rspq_highpri_end</a> multiple times with short delays in-between. The RSP will process them in order. Notice that there is a overhead in doing so, so it might be advisable to keep the high-priority mode active for a longer period if possible. On the other hand, a shorter high-priority queue allows for the RSP to switch back to processing the normal queue before the next one is created.</p>
<dl class="section note"><dt>Note</dt><dd>It is not possible to create a block while the high-priority queue is active. Arrange for constructing blocks beforehand.</dd>
<dd>
It is currently not possible to call a block from the high-priority queue. (FIXME: to be implemented) </dd></dl>

</div>
</div>
<a id="ae495b6d8ec49169f05e523fe564f9f4b" name="ae495b6d8ec49169f05e523fe564f9f4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae495b6d8ec49169f05e523fe564f9f4b">&#9670;&nbsp;</a></span>rspq_highpri_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rspq_highpri_end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finish building the high-priority queue and close it. </p>
<p >This function terminates and closes the high-priority queue. After this command is called, all following commands will be added to the normal queue.</p>
<p >Notice that the RSP does not wait for this function to be called: it will start running the high-priority queue as soon as possible, even while it is being built. </p>

</div>
</div>
<a id="a577581d5bf9cfecaa6a1becf3da21d6c" name="a577581d5bf9cfecaa6a1becf3da21d6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a577581d5bf9cfecaa6a1becf3da21d6c">&#9670;&nbsp;</a></span>rspq_highpri_sync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rspq_highpri_sync </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for the RSP to finish processing all high-priority queues. </p>
<p >This function will spin-lock waiting for the RSP to finish processing all high-priority queues. It is meant for debugging purposes or for situations in which the high-priority queue is known to be very short and fast to run. Also note that it is not possible to create syncpoints in the high-priority queue. </p>

</div>
</div>
<a id="aee149426cb6d86a71812a27b618d59c9" name="aee149426cb6d86a71812a27b618d59c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee149426cb6d86a71812a27b618d59c9">&#9670;&nbsp;</a></span>rspq_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rspq_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the RSPQ library. </p>
<p >This should be called by the initialization functions of the higher-level libraries using the RSP command queue. It can be safely called multiple times without side effects.</p>
<p >It is not required by applications to call this explicitly in the main function. </p>

</div>
</div>
<a id="ae6c56593b83d4bbd5f6229a5a6a7ff18" name="ae6c56593b83d4bbd5f6229a5a6a7ff18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6c56593b83d4bbd5f6229a5a6a7ff18">&#9670;&nbsp;</a></span>rspq_noop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rspq_noop </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enqueue a no-op command in the queue. </p>
<p >This function enqueues a command that does nothing. This is mostly useful for debugging purposes. </p>

</div>
</div>
<a id="a24f709a49410891134670ee3a55ff27b" name="a24f709a49410891134670ee3a55ff27b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24f709a49410891134670ee3a55ff27b">&#9670;&nbsp;</a></span>rspq_overlay_get_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * rspq_overlay_get_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrsp__ucode__t.html">rsp_ucode_t</a> *&#160;</td>
          <td class="paramname"><em>overlay_ucode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a pointer to the overlay state (in RDRAM) </p>
<p >Overlays can define a section of DMEM as persistent state. This area will be preserved across overlay switching, by reading back into RDRAM the DMEM contents when the overlay is switched away.</p>
<p >This function returns a pointer to the state area in RDRAM (not DMEM). It is meant to modify the state on the CPU side while the overlay is not loaded. The layout of the state and its size should be known to the caller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">overlay_ucode</td><td>The ucode overlay for which the state pointer will be returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the overlay state (in RDRAM) </dd></dl>

</div>
</div>
<a id="a072c51be5126cfe5f914aefc52de950a" name="a072c51be5126cfe5f914aefc52de950a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a072c51be5126cfe5f914aefc52de950a">&#9670;&nbsp;</a></span>rspq_overlay_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t rspq_overlay_register </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrsp__ucode__t.html">rsp_ucode_t</a> *&#160;</td>
          <td class="paramname"><em>overlay_ucode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a rspq overlay into the RSP queue engine. </p>
<p >This function registers a rspq overlay into the queue engine. An overlay is a RSP ucode that has been written to be compatible with the queue engine (see rsp_queue.inc for instructions) and is thus able to execute commands that are enqueued in the queue. An overlay doesn't have a single entry point: it exposes multiple functions bound to different commands, that will be called by the queue engine when the commands are enqueued.</p>
<p >The function returns the overlay ID, which is the ID to use to enqueue commands for this overlay. The overlay ID must be passed to <a class="el" href="rspq_8h.html#aefec193be7de05f725738beeb3775634" title="Write a new command into the RSP queue.">rspq_write</a> when adding new commands. rspq allows up to 16 overlays to be registered simultaneously, as the overlay ID occupies the top 4 bits of each command. The lower 4 bits specify the command ID, so in theory each overlay could offer a maximum of 16 commands. To overcome this limitation, this function will reserve multiple consecutive IDs in case an overlay with more than 16 commands is registered. These additional IDs are silently occupied and never need to be specified explicitly when queueing commands.</p>
<p >For example if an overlay with 32 commands were registered, this function could return ID 0x60, and ID 0x70 would implicitly be reserved as well. To queue the twenty first command of this overlay, you would write <code><a class="el" href="rspq_8h.html#aefec193be7de05f725738beeb3775634" title="Write a new command into the RSP queue.">rspq_write(ovl_id, 0x14, ...)</a></code>, where <code>ovl_id</code> is the value that was returned by this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">overlay_ucode</td><td>The overlay to register</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The overlay ID that has been assigned to the overlay. Note that this value will be preshifted by 28 (eg: 0x60000000 for ID 6), as this is the expected format used by <a class="el" href="rspq_8h.html#aefec193be7de05f725738beeb3775634" title="Write a new command into the RSP queue.">rspq_write</a>. </dd></dl>

</div>
</div>
<a id="a79bb76d8572e721cb4fdd322a6f6cb43" name="a79bb76d8572e721cb4fdd322a6f6cb43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79bb76d8572e721cb4fdd322a6f6cb43">&#9670;&nbsp;</a></span>rspq_overlay_register_static()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rspq_overlay_register_static </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrsp__ucode__t.html">rsp_ucode_t</a> *&#160;</td>
          <td class="paramname"><em>overlay_ucode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>overlay_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register an overlay into the RSP queue engine assigning a static ID to it. </p>
<p >This function works similar to <a class="el" href="rspq_8h.html#a072c51be5126cfe5f914aefc52de950a" title="Register a rspq overlay into the RSP queue engine.">rspq_overlay_register</a>, except it will attempt to assign the specified ID to the overlay instead of automatically choosing one. Note that if the ID (or a consecutive IDs) is already used by another overlay, this function will assert, so careful usage is advised.</p>
<p >Assigning a static ID can mostly be useful for debugging purposes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">overlay_ucode</td><td>The ucode to register </td></tr>
    <tr><td class="paramname">overlay_id</td><td>The ID to register the overlay with. This ID must be preshifted by 28 (eg: 0x40000000).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rspq_8h.html#a072c51be5126cfe5f914aefc52de950a" title="Register a rspq overlay into the RSP queue engine.">rspq_overlay_register</a> </dd></dl>

</div>
</div>
<a id="a1e9b877ae18c66a9258c1b5d04c06e20" name="a1e9b877ae18c66a9258c1b5d04c06e20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e9b877ae18c66a9258c1b5d04c06e20">&#9670;&nbsp;</a></span>rspq_overlay_unregister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rspq_overlay_unregister </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>overlay_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregister a ucode overlay from the RSP queue engine. </p>
<p >This function removes an overlay that has previously been registered with <a class="el" href="rspq_8h.html#a072c51be5126cfe5f914aefc52de950a" title="Register a rspq overlay into the RSP queue engine.">rspq_overlay_register</a> or <a class="el" href="rspq_8h.html#a79bb76d8572e721cb4fdd322a6f6cb43" title="Register an overlay into the RSP queue engine assigning a static ID to it.">rspq_overlay_register_static</a> from the queue engine. After calling this function, the specified overlay ID (and consecutive IDs in case the overlay has more than 16 commands) is no longer valid and must not be used to write new commands into the queue.</p>
<p >Note that when new overlays are registered, the queue engine may recycle IDs from previously unregistered overlays.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">overlay_id</td><td>The ID of the ucode (as returned by <a class="el" href="rspq_8h.html#a072c51be5126cfe5f914aefc52de950a" title="Register a rspq overlay into the RSP queue engine.">rspq_overlay_register</a>) to unregister. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae4048a732f6dc351895e57654a3ea6cc" name="ae4048a732f6dc351895e57654a3ea6cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4048a732f6dc351895e57654a3ea6cc">&#9670;&nbsp;</a></span>rspq_signal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rspq_signal </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>signal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enqueue a command that sets a signal in SP status. </p>
<p >The SP status register has 8 bits called "signals" that can be atomically set or cleared by both the CPU and the RSP. They can be used to provide asynchronous communication.</p>
<p >This function allows to add a command to the queue that will set and/or clear a combination of the above bits.</p>
<p >Notice that signal bits 2-7 are used by the RSP queue engine itself, so this function must only be used for bits 0 and 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">signal</td><td>A signal set/clear mask created by composing SP_WSTATUS_* defines.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is an advanced function that should be used rarely. Most synchronization requirements should be fulfilled via <a class="el" href="rspq_8h.html#a4d6fb26b5312a98ad83f758cd7514e6e" title="Create a syncpoint in the queue.">rspq_syncpoint_new</a> which is easier to use. </dd></dl>

</div>
</div>
<a id="a86e818e81e25912cddbb86672dcd9976" name="a86e818e81e25912cddbb86672dcd9976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86e818e81e25912cddbb86672dcd9976">&#9670;&nbsp;</a></span>rspq_syncpoint_check()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rspq_syncpoint_check </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rspq_8h.html#a80d73a81524565e802d89bb14523b1cf">rspq_syncpoint_t</a>&#160;</td>
          <td class="paramname"><em>sync_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether a syncpoint was reached by RSP or not. </p>
<p >This function checks whether a syncpoint was reached. It never blocks. If you need to wait for a syncpoint to be reached, use <a class="el" href="rspq_8h.html#ac3aa6ceb175fd56a5969fa01985e1d60" title="Wait until a syncpoint is reached by RSP.">rspq_syncpoint_wait</a> instead of polling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sync_id</td><td>ID of the syncpoint to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the RSP has reached the syncpoint, false otherwise</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rspq_8h.html#a80d73a81524565e802d89bb14523b1cf" title="A syncpoint in the queue.">rspq_syncpoint_t</a> </dd></dl>

</div>
</div>
<a id="a4d6fb26b5312a98ad83f758cd7514e6e" name="a4d6fb26b5312a98ad83f758cd7514e6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d6fb26b5312a98ad83f758cd7514e6e">&#9670;&nbsp;</a></span>rspq_syncpoint_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rspq_8h.html#a80d73a81524565e802d89bb14523b1cf">rspq_syncpoint_t</a> rspq_syncpoint_new </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a syncpoint in the queue. </p>
<p >This function creates a new "syncpoint" referencing the current position in the queue. It is possible to later check when the syncpoint is reached by the RSP via <a class="el" href="rspq_8h.html#a86e818e81e25912cddbb86672dcd9976" title="Check whether a syncpoint was reached by RSP or not.">rspq_syncpoint_check</a> and <a class="el" href="rspq_8h.html#ac3aa6ceb175fd56a5969fa01985e1d60" title="Wait until a syncpoint is reached by RSP.">rspq_syncpoint_wait</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>ID of the just-created syncpoint.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>It is not possible to create a syncpoint within a block because it is meant to be a one-time event. Otherwise the same syncpoint would potentially be triggered multiple times, which is not supported.</dd>
<dd>
It is not possible to create a syncpoint from the high-priority queue due to the implementation requiring syncpoints to be triggered in the same order they have been created.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rspq_8h.html#a80d73a81524565e802d89bb14523b1cf" title="A syncpoint in the queue.">rspq_syncpoint_t</a> </dd></dl>

</div>
</div>
<a id="ac3aa6ceb175fd56a5969fa01985e1d60" name="ac3aa6ceb175fd56a5969fa01985e1d60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3aa6ceb175fd56a5969fa01985e1d60">&#9670;&nbsp;</a></span>rspq_syncpoint_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rspq_syncpoint_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rspq_8h.html#a80d73a81524565e802d89bb14523b1cf">rspq_syncpoint_t</a>&#160;</td>
          <td class="paramname"><em>sync_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait until a syncpoint is reached by RSP. </p>
<p >This function blocks waiting for the RSP to reach the specified syncpoint. If the syncpoint was already called at the moment of call, the function exits immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sync_id</td><td>ID of the syncpoint to wait for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rspq_8h.html#a80d73a81524565e802d89bb14523b1cf" title="A syncpoint in the queue.">rspq_syncpoint_t</a> </dd></dl>

</div>
</div>
<a id="ab44674d8d8266f4a515b3fd4c6365b0b" name="ab44674d8d8266f4a515b3fd4c6365b0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab44674d8d8266f4a515b3fd4c6365b0b">&#9670;&nbsp;</a></span>rspq_write_arg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rspq_write_arg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rspq_8h.html#structrspq__write__t">rspq_write_t</a> *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add one argument to the command being enqueued. </p>
<p >This function adds one more argument to the command currently being enqueued. This function must be called after <a class="el" href="rspq_8h.html#a7853bba8cbf5773669b9e9ebd7f474cc" title="Begin writing a new command into the RSP queue.">rspq_write_begin</a>; it should be called multiple times (one per argument word), and then <a class="el" href="rspq_8h.html#a08f96b9087b04fe6a5f224728ff47701" title="Finish enqueuing a command into the queue.">rspq_write_end</a> should be called to terminate enqueuing the command.</p>
<p >See also <a class="el" href="rspq_8h.html#aefec193be7de05f725738beeb3775634" title="Write a new command into the RSP queue.">rspq_write</a> for a more straightforward API for command enqueuing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>The write cursor (returned by <a class="el" href="rspq_8h.html#a7853bba8cbf5773669b9e9ebd7f474cc" title="Begin writing a new command into the RSP queue.">rspq_write_begin</a>) </td></tr>
    <tr><td class="paramname">value</td><td>New 32-bit argument word to add to the command.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The first argument must have its MSB set to 0, to leave space for the command ID. See <a class="el" href="rspq_8h.html#aefec193be7de05f725738beeb3775634" title="Write a new command into the RSP queue.">rspq_write</a> documentation for a more complete explanation.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rspq_8h.html#a7853bba8cbf5773669b9e9ebd7f474cc" title="Begin writing a new command into the RSP queue.">rspq_write_begin</a> </dd>
<dd>
<a class="el" href="rspq_8h.html#a08f96b9087b04fe6a5f224728ff47701" title="Finish enqueuing a command into the queue.">rspq_write_end</a> </dd>
<dd>
<a class="el" href="rspq_8h.html#aefec193be7de05f725738beeb3775634" title="Write a new command into the RSP queue.">rspq_write</a> </dd></dl>

</div>
</div>
<a id="a7853bba8cbf5773669b9e9ebd7f474cc" name="a7853bba8cbf5773669b9e9ebd7f474cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7853bba8cbf5773669b9e9ebd7f474cc">&#9670;&nbsp;</a></span>rspq_write_begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rspq_8h.html#structrspq__write__t">rspq_write_t</a> rspq_write_begin </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ovl_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cmd_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Begin writing a new command into the RSP queue. </p>
<p >This command initiates a sequence to enqueue a new command into the RSP queue. Call this command passing the overlay ID and command ID of the command to create. Then, call <a class="el" href="rspq_8h.html#ab44674d8d8266f4a515b3fd4c6365b0b" title="Add one argument to the command being enqueued.">rspq_write_arg</a> once per each argument word that composes the command. Finally, call <a class="el" href="rspq_8h.html#a08f96b9087b04fe6a5f224728ff47701" title="Finish enqueuing a command into the queue.">rspq_write_end</a> to finalize and enqueue the command.</p>
<p >A sequence made by <a class="el" href="rspq_8h.html#a7853bba8cbf5773669b9e9ebd7f474cc" title="Begin writing a new command into the RSP queue.">rspq_write_begin</a>, <a class="el" href="rspq_8h.html#ab44674d8d8266f4a515b3fd4c6365b0b" title="Add one argument to the command being enqueued.">rspq_write_arg</a>, <a class="el" href="rspq_8h.html#a08f96b9087b04fe6a5f224728ff47701" title="Finish enqueuing a command into the queue.">rspq_write_end</a> is functionally equivalent to a call to <a class="el" href="rspq_8h.html#aefec193be7de05f725738beeb3775634" title="Write a new command into the RSP queue.">rspq_write</a>, but it allows to create bigger commands, and might better fit some situations where arguments are calculated on the fly. Performance-wise, the code generated by <a class="el" href="rspq_8h.html#a7853bba8cbf5773669b9e9ebd7f474cc" title="Begin writing a new command into the RSP queue.">rspq_write_begin</a> + <a class="el" href="rspq_8h.html#ab44674d8d8266f4a515b3fd4c6365b0b" title="Add one argument to the command being enqueued.">rspq_write_arg</a> + <a class="el" href="rspq_8h.html#a08f96b9087b04fe6a5f224728ff47701" title="Finish enqueuing a command into the queue.">rspq_write_end</a> should be very similar to a single call to <a class="el" href="rspq_8h.html#aefec193be7de05f725738beeb3775634" title="Write a new command into the RSP queue.">rspq_write</a>, though just a bit slower. It is advisable to use <a class="el" href="rspq_8h.html#aefec193be7de05f725738beeb3775634" title="Write a new command into the RSP queue.">rspq_write</a> whenever possible.</p>
<p >Make sure to read the documentation of <a class="el" href="rspq_8h.html#aefec193be7de05f725738beeb3775634" title="Write a new command into the RSP queue.">rspq_write</a> as well for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ovl_id</td><td>The overlay ID of the command to enqueue. Notice that this must be a value preshifted by 28, as returned by <a class="el" href="rspq_8h.html#a072c51be5126cfe5f914aefc52de950a" title="Register a rspq overlay into the RSP queue engine.">rspq_overlay_register</a>. </td></tr>
    <tr><td class="paramname">cmd_id</td><td>Index of the command to call, within the overlay. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the commands in 32-bit words </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A write cursor, that must be passed to <a class="el" href="rspq_8h.html#ab44674d8d8266f4a515b3fd4c6365b0b" title="Add one argument to the command being enqueued.">rspq_write_arg</a> and <a class="el" href="rspq_8h.html#a08f96b9087b04fe6a5f224728ff47701" title="Finish enqueuing a command into the queue.">rspq_write_end</a></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rspq_8h.html#ab44674d8d8266f4a515b3fd4c6365b0b" title="Add one argument to the command being enqueued.">rspq_write_arg</a> </dd>
<dd>
<a class="el" href="rspq_8h.html#a08f96b9087b04fe6a5f224728ff47701" title="Finish enqueuing a command into the queue.">rspq_write_end</a> </dd>
<dd>
<a class="el" href="rspq_8h.html#aefec193be7de05f725738beeb3775634" title="Write a new command into the RSP queue.">rspq_write</a> </dd></dl>

</div>
</div>
<a id="a08f96b9087b04fe6a5f224728ff47701" name="a08f96b9087b04fe6a5f224728ff47701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08f96b9087b04fe6a5f224728ff47701">&#9670;&nbsp;</a></span>rspq_write_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rspq_write_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rspq_8h.html#structrspq__write__t">rspq_write_t</a> *&#160;</td>
          <td class="paramname"><em>w</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finish enqueuing a command into the queue. </p>
<p >This function should be called to terminate a sequence for command enqueuing, after <a class="el" href="rspq_8h.html#a7853bba8cbf5773669b9e9ebd7f474cc" title="Begin writing a new command into the RSP queue.">rspq_write_begin</a> and (multiple) calls to <a class="el" href="rspq_8h.html#ab44674d8d8266f4a515b3fd4c6365b0b" title="Add one argument to the command being enqueued.">rspq_write_arg</a>.</p>
<p >After calling this command, the write cursor cannot be used anymore.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>The write cursor (returned by <a class="el" href="rspq_8h.html#a7853bba8cbf5773669b9e9ebd7f474cc" title="Begin writing a new command into the RSP queue.">rspq_write_begin</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rspq_8h.html#a7853bba8cbf5773669b9e9ebd7f474cc" title="Begin writing a new command into the RSP queue.">rspq_write_begin</a> </dd>
<dd>
<a class="el" href="rspq_8h.html#ab44674d8d8266f4a515b3fd4c6365b0b" title="Add one argument to the command being enqueued.">rspq_write_arg</a> </dd>
<dd>
<a class="el" href="rspq_8h.html#aefec193be7de05f725738beeb3775634" title="Write a new command into the RSP queue.">rspq_write</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jul 7 2022 08:55:10 for libdragon by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
