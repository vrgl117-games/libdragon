<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libdragon: Audio Subsystem</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">libdragon
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#files">Files</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Audio Subsystem<div class="ingroups"><a class="el" href="group__libdragon.html">libdragon</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Interface to the N64 audio hardware.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="groups" name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__mixer"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mixer.html">Audio mixer</a></td></tr>
<tr class="memdesc:group__mixer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flexible, composable, fast, RSP-based audio mixer. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="files" name="files"></a>
Files</h2></td></tr>
<tr class="memitem:audio_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="audio_8c.html">audio.c</a></td></tr>
<tr class="memdesc:audio_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Audio Subsystem. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:audio_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="audio_8h.html">audio.h</a></td></tr>
<tr class="memdesc:audio_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Audio Subsystem. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaac028f4c15ac7f78a44be5db76cfbec7"><td class="memItemLeft" align="right" valign="top"><a id="gaac028f4c15ac7f78a44be5db76cfbec7" name="gaac028f4c15ac7f78a44be5db76cfbec7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NUM_BUFFERS</b>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:gaac028f4c15ac7f78a44be5db76cfbec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of buffers the audio subsytem allocates and manages. <br /></td></tr>
<tr class="separator:gaac028f4c15ac7f78a44be5db76cfbec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b0880357ad7cafc9780a3ed72447816"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__audio.html#ga1b0880357ad7cafc9780a3ed72447816">CALC_BUFFER</a>(x)&#160;&#160;&#160;( ( ( ( x ) / 25 ) &gt;&gt; 3 ) &lt;&lt; 3 )</td></tr>
<tr class="memdesc:ga1b0880357ad7cafc9780a3ed72447816"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro that calculates the size of a buffer based on frequency.  <a href="group__audio.html#ga1b0880357ad7cafc9780a3ed72447816">More...</a><br /></td></tr>
<tr class="separator:ga1b0880357ad7cafc9780a3ed72447816"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga8ef2eb966a8552f3d19526753b98427f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__audio.html#ga8ef2eb966a8552f3d19526753b98427f">audio_init</a> (const int frequency, int numbuffers)</td></tr>
<tr class="memdesc:ga8ef2eb966a8552f3d19526753b98427f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the audio subsystem.  <a href="group__audio.html#ga8ef2eb966a8552f3d19526753b98427f">More...</a><br /></td></tr>
<tr class="separator:ga8ef2eb966a8552f3d19526753b98427f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga456542c1cf5d749b2a351778f932f7a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__audio.html#ga456542c1cf5d749b2a351778f932f7a6">audio_set_buffer_callback</a> (<a class="el" href="audio_8h.html#aecfbc74a751594695ce3706d199da203">audio_fill_buffer_callback</a> fill_buffer_callback)</td></tr>
<tr class="memdesc:ga456542c1cf5d749b2a351778f932f7a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install a audio callback to fill the audio buffer when required.  <a href="group__audio.html#ga456542c1cf5d749b2a351778f932f7a6">More...</a><br /></td></tr>
<tr class="separator:ga456542c1cf5d749b2a351778f932f7a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad927b510bc46c3e0ebcfae81706fec06"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__audio.html#gad927b510bc46c3e0ebcfae81706fec06">audio_close</a> ()</td></tr>
<tr class="memdesc:gad927b510bc46c3e0ebcfae81706fec06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the audio subsystem.  <a href="group__audio.html#gad927b510bc46c3e0ebcfae81706fec06">More...</a><br /></td></tr>
<tr class="separator:gad927b510bc46c3e0ebcfae81706fec06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga977622d0345b9951d9259d5ff202de8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__audio.html#ga977622d0345b9951d9259d5ff202de8c">audio_pause</a> (bool pause)</td></tr>
<tr class="memdesc:ga977622d0345b9951d9259d5ff202de8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pause or resume audio playback.  <a href="group__audio.html#ga977622d0345b9951d9259d5ff202de8c">More...</a><br /></td></tr>
<tr class="separator:ga977622d0345b9951d9259d5ff202de8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab06cc34952ebf6952af37f7080743c98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__audio.html#gab06cc34952ebf6952af37f7080743c98">audio_write</a> (const short *const buffer)</td></tr>
<tr class="memdesc:gab06cc34952ebf6952af37f7080743c98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a chunk of audio data.  <a href="group__audio.html#gab06cc34952ebf6952af37f7080743c98">More...</a><br /></td></tr>
<tr class="separator:gab06cc34952ebf6952af37f7080743c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8aee840f13aa6903fef4c092d0ffa704"><td class="memItemLeft" align="right" valign="top">short *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__audio.html#ga8aee840f13aa6903fef4c092d0ffa704">audio_write_begin</a> (void)</td></tr>
<tr class="memdesc:ga8aee840f13aa6903fef4c092d0ffa704"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start writing to the first free internal buffer.  <a href="group__audio.html#ga8aee840f13aa6903fef4c092d0ffa704">More...</a><br /></td></tr>
<tr class="separator:ga8aee840f13aa6903fef4c092d0ffa704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac872c4749acb1685ebeabc1f9d02c0bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__audio.html#gac872c4749acb1685ebeabc1f9d02c0bf">audio_write_end</a> (void)</td></tr>
<tr class="memdesc:gac872c4749acb1685ebeabc1f9d02c0bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complete writing to an internal buffer.  <a href="group__audio.html#gac872c4749acb1685ebeabc1f9d02c0bf">More...</a><br /></td></tr>
<tr class="separator:gac872c4749acb1685ebeabc1f9d02c0bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0c6a38d6ce470872e4016ecc6d9abd3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__audio.html#gad0c6a38d6ce470872e4016ecc6d9abd3">audio_write_silence</a> ()</td></tr>
<tr class="memdesc:gad0c6a38d6ce470872e4016ecc6d9abd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a chunk of silence.  <a href="group__audio.html#gad0c6a38d6ce470872e4016ecc6d9abd3">More...</a><br /></td></tr>
<tr class="separator:gad0c6a38d6ce470872e4016ecc6d9abd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga762b8b0c8957798c66ee158ce513e05e"><td class="memItemLeft" align="right" valign="top">volatile int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__audio.html#ga762b8b0c8957798c66ee158ce513e05e">audio_can_write</a> ()</td></tr>
<tr class="memdesc:ga762b8b0c8957798c66ee158ce513e05e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether there is an empty buffer to write to.  <a href="group__audio.html#ga762b8b0c8957798c66ee158ce513e05e">More...</a><br /></td></tr>
<tr class="separator:ga762b8b0c8957798c66ee158ce513e05e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6892c9dfdd99e00a4285fe05058d6a37"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__audio.html#ga6892c9dfdd99e00a4285fe05058d6a37">audio_get_frequency</a> ()</td></tr>
<tr class="memdesc:ga6892c9dfdd99e00a4285fe05058d6a37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return actual frequency of audio playback.  <a href="group__audio.html#ga6892c9dfdd99e00a4285fe05058d6a37">More...</a><br /></td></tr>
<tr class="separator:ga6892c9dfdd99e00a4285fe05058d6a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12decba34a007365bf749874e044b88d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__audio.html#ga12decba34a007365bf749874e044b88d">audio_get_buffer_length</a> ()</td></tr>
<tr class="memdesc:ga12decba34a007365bf749874e044b88d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of stereo samples that fit into an allocated buffer.  <a href="group__audio.html#ga12decba34a007365bf749874e044b88d">More...</a><br /></td></tr>
<tr class="separator:ga12decba34a007365bf749874e044b88d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">DAC rates for different regions</h2></td></tr>
<tr class="memitem:ga20d82d21fbcc87d5fe0aa5d89362e38b"><td class="memItemLeft" align="right" valign="top"><a id="ga20d82d21fbcc87d5fe0aa5d89362e38b" name="ga20d82d21fbcc87d5fe0aa5d89362e38b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>AI_NTSC_DACRATE</b>&#160;&#160;&#160;48681812</td></tr>
<tr class="memdesc:ga20d82d21fbcc87d5fe0aa5d89362e38b"><td class="mdescLeft">&#160;</td><td class="mdescRight">NTSC DAC rate. <br /></td></tr>
<tr class="separator:ga20d82d21fbcc87d5fe0aa5d89362e38b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73839b3328dad9a9280c139cd30eed0f"><td class="memItemLeft" align="right" valign="top"><a id="ga73839b3328dad9a9280c139cd30eed0f" name="ga73839b3328dad9a9280c139cd30eed0f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>AI_PAL_DACRATE</b>&#160;&#160;&#160;49656530</td></tr>
<tr class="memdesc:ga73839b3328dad9a9280c139cd30eed0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">PAL DAC rate. <br /></td></tr>
<tr class="separator:ga73839b3328dad9a9280c139cd30eed0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddf370a3192ea11675e3743c02c90cce"><td class="memItemLeft" align="right" valign="top"><a id="gaddf370a3192ea11675e3743c02c90cce" name="gaddf370a3192ea11675e3743c02c90cce"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>AI_MPAL_DACRATE</b>&#160;&#160;&#160;48628316</td></tr>
<tr class="memdesc:gaddf370a3192ea11675e3743c02c90cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">MPAL DAC rate. <br /></td></tr>
<tr class="separator:gaddf370a3192ea11675e3743c02c90cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">AI Status Register Values</h2></td></tr>
<tr class="memitem:ga7811a8498f902f7ba4ab71ace71996ad"><td class="memItemLeft" align="right" valign="top"><a id="ga7811a8498f902f7ba4ab71ace71996ad" name="ga7811a8498f902f7ba4ab71ace71996ad"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>AI_STATUS_BUSY</b>&#160;&#160;&#160;( 1 &lt;&lt; 30 )</td></tr>
<tr class="memdesc:ga7811a8498f902f7ba4ab71ace71996ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit representing that the AI is busy. <br /></td></tr>
<tr class="separator:ga7811a8498f902f7ba4ab71ace71996ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6fa307322df53a3592ddf7379864b55"><td class="memItemLeft" align="right" valign="top"><a id="gae6fa307322df53a3592ddf7379864b55" name="gae6fa307322df53a3592ddf7379864b55"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>AI_STATUS_FULL</b>&#160;&#160;&#160;( 1 &lt;&lt; 31 )</td></tr>
<tr class="memdesc:gae6fa307322df53a3592ddf7379864b55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit representing that the AI is full. <br /></td></tr>
<tr class="separator:gae6fa307322df53a3592ddf7379864b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >Interface to the N64 audio hardware. </p>
<p >The audio subsystem handles queueing up chunks of audio data for playback using the N64 audio DAC. The audio subsystem handles DMAing chunks of data to the audio DAC as well as audio callbacks when there is room for another chunk to be written. Buffer size is calculated automatically based on the requested audio frequency. The audio subsystem accomplishes this by interfacing with the audio interface (AI) registers.</p>
<p >Because the audio DAC is timed off of the system clock of the N64, the audio subsystem needs to know what region the N64 is from. This is due to the fact that the system clock is timed differently for PAL, NTSC and MPAL regions. This is handled automatically by the audio subsystem based on settings left by the bootloader.</p>
<p >Code attempting to output audio on the N64 should initialize the audio subsystem at the desired frequency and with the desired number of buffers using <a class="el" href="group__audio.html#ga8ef2eb966a8552f3d19526753b98427f" title="Initialize the audio subsystem.">audio_init</a>. More audio buffers allows for smaller chances of audio glitches but means that there will be more latency in sound output. When new data is available to be output, code should check to see if there is room in the output buffers using <a class="el" href="group__audio.html#ga762b8b0c8957798c66ee158ce513e05e" title="Return whether there is an empty buffer to write to.">audio_can_write</a>. Code can probe the current frequency and buffer size using <a class="el" href="group__audio.html#ga6892c9dfdd99e00a4285fe05058d6a37" title="Return actual frequency of audio playback.">audio_get_frequency</a> and <a class="el" href="group__audio.html#ga12decba34a007365bf749874e044b88d" title="Get the number of stereo samples that fit into an allocated buffer.">audio_get_buffer_length</a> respectively. When there is additional room, code can add new data to the output buffers using <a class="el" href="group__audio.html#gab06cc34952ebf6952af37f7080743c98" title="Write a chunk of audio data.">audio_write</a>. Be careful as this is a blocking operation, so if code doesn't check for adequate room first, this function will not return until there is room and the samples have been written. When all audio has been written, code should call <a class="el" href="group__audio.html#gad927b510bc46c3e0ebcfae81706fec06" title="Close the audio subsystem.">audio_close</a> to shut down the audio subsystem cleanly. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga1b0880357ad7cafc9780a3ed72447816" name="ga1b0880357ad7cafc9780a3ed72447816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b0880357ad7cafc9780a3ed72447816">&#9670;&nbsp;</a></span>CALC_BUFFER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CALC_BUFFER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;( ( ( ( x ) / 25 ) &gt;&gt; 3 ) &lt;&lt; 3 )</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro that calculates the size of a buffer based on frequency. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Frequency the AI is running at</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of the buffer in bytes rounded to an 8 byte boundary </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga762b8b0c8957798c66ee158ce513e05e" name="ga762b8b0c8957798c66ee158ce513e05e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga762b8b0c8957798c66ee158ce513e05e">&#9670;&nbsp;</a></span>audio_can_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile int audio_can_write </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return whether there is an empty buffer to write to. </p>
<p >This function will check to see if there are any buffers that are not full to write data to. If all buffers are full, wait until the AI has played back the next buffer in its queue and try writing again. </p>

</div>
</div>
<a id="gad927b510bc46c3e0ebcfae81706fec06" name="gad927b510bc46c3e0ebcfae81706fec06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad927b510bc46c3e0ebcfae81706fec06">&#9670;&nbsp;</a></span>audio_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void audio_close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close the audio subsystem. </p>
<p >This function closes the audio system and cleans up any internal memory allocated by <a class="el" href="group__audio.html#ga8ef2eb966a8552f3d19526753b98427f" title="Initialize the audio subsystem.">audio_init</a>. </p>

</div>
</div>
<a id="ga12decba34a007365bf749874e044b88d" name="ga12decba34a007365bf749874e044b88d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12decba34a007365bf749874e044b88d">&#9670;&nbsp;</a></span>audio_get_buffer_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int audio_get_buffer_length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of stereo samples that fit into an allocated buffer. </p>
<dl class="section note"><dt>Note</dt><dd>To get the number of bytes to allocate, multiply the return by 2 * sizeof( short )</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The number of stereo samples in an allocated buffer </dd></dl>

</div>
</div>
<a id="ga6892c9dfdd99e00a4285fe05058d6a37" name="ga6892c9dfdd99e00a4285fe05058d6a37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6892c9dfdd99e00a4285fe05058d6a37">&#9670;&nbsp;</a></span>audio_get_frequency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int audio_get_frequency </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return actual frequency of audio playback. </p>
<dl class="section return"><dt>Returns</dt><dd>Frequency in Hz of the audio playback </dd></dl>

</div>
</div>
<a id="ga8ef2eb966a8552f3d19526753b98427f" name="ga8ef2eb966a8552f3d19526753b98427f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ef2eb966a8552f3d19526753b98427f">&#9670;&nbsp;</a></span>audio_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void audio_init </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>frequency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numbuffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the audio subsystem. </p>
<p >This function will set up the AI to play at a given frequency and allocate a number of back buffers to write data to.</p>
<dl class="section note"><dt>Note</dt><dd>Before re-initializing the audio subsystem to a new playback frequency, remember to call <a class="el" href="group__audio.html#gad927b510bc46c3e0ebcfae81706fec06" title="Close the audio subsystem.">audio_close</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">frequency</td><td>The frequency in Hz to play back samples at </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numbuffers</td><td>The number of buffers to allocate internally </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga977622d0345b9951d9259d5ff202de8c" name="ga977622d0345b9951d9259d5ff202de8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga977622d0345b9951d9259d5ff202de8c">&#9670;&nbsp;</a></span>audio_pause()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void audio_pause </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pause</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pause or resume audio playback. </p>
<p >Should only be used when a fill_buffer_callback has been set in <a class="el" href="group__audio.html#ga8ef2eb966a8552f3d19526753b98427f" title="Initialize the audio subsystem.">audio_init</a>. Silence will be generated while playback is paused. </p>

</div>
</div>
<a id="ga456542c1cf5d749b2a351778f932f7a6" name="ga456542c1cf5d749b2a351778f932f7a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga456542c1cf5d749b2a351778f932f7a6">&#9670;&nbsp;</a></span>audio_set_buffer_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void audio_set_buffer_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="audio_8h.html#aecfbc74a751594695ce3706d199da203">audio_fill_buffer_callback</a>&#160;</td>
          <td class="paramname"><em>fill_buffer_callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install a audio callback to fill the audio buffer when required. </p>
<p >This function allows to implement a pull-based audio system. It registers a callback which will be invoked under interrupt whenever the AI is ready to have more samples enqueued. The callback can fill the provided audio data with samples that will be enqueued for DMA to AI.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fill_buffer_callback</td><td>Callback to fill an empty audio buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab06cc34952ebf6952af37f7080743c98" name="gab06cc34952ebf6952af37f7080743c98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab06cc34952ebf6952af37f7080743c98">&#9670;&nbsp;</a></span>audio_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void audio_write </td>
          <td>(</td>
          <td class="paramtype">const short *const&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a chunk of audio data. </p>
<p >This function takes a chunk of audio data and writes it to an internal buffer which will be played back by the audio system as soon as room becomes available in the AI. The buffer should contain stereo interleaved samples and be exactly <a class="el" href="group__audio.html#ga12decba34a007365bf749874e044b88d" title="Get the number of stereo samples that fit into an allocated buffer.">audio_get_buffer_length</a> stereo samples long.</p>
<p >To improve performance and avoid the memory copy, use <a class="el" href="group__audio.html#ga8aee840f13aa6903fef4c092d0ffa704" title="Start writing to the first free internal buffer.">audio_write_begin</a> and <a class="el" href="group__audio.html#gac872c4749acb1685ebeabc1f9d02c0bf" title="Complete writing to an internal buffer.">audio_write_end</a> instead.</p>
<dl class="section note"><dt>Note</dt><dd>This function will block until there is room to write an audio sample. If you do not want to block, check to see if there is room by calling <a class="el" href="group__audio.html#ga762b8b0c8957798c66ee158ce513e05e" title="Return whether there is an empty buffer to write to.">audio_can_write</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Buffer containing stereo samples to be played </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8aee840f13aa6903fef4c092d0ffa704" name="ga8aee840f13aa6903fef4c092d0ffa704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8aee840f13aa6903fef4c092d0ffa704">&#9670;&nbsp;</a></span>audio_write_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short * audio_write_begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start writing to the first free internal buffer. </p>
<p >This function is similar to <a class="el" href="group__audio.html#gab06cc34952ebf6952af37f7080743c98" title="Write a chunk of audio data.">audio_write</a> but instead of taking samples and copying them to an internal buffer, it returns the pointer to the internal buffer. This allows generating the samples directly in the buffer that will be sent via DMA to AI, without any subsequent memory copy.</p>
<p >The buffer should be filled with stereo interleaved samples, and exactly <a class="el" href="group__audio.html#ga12decba34a007365bf749874e044b88d" title="Get the number of stereo samples that fit into an allocated buffer.">audio_get_buffer_length</a> samples should be written.</p>
<p >After you have written the samples, call <a class="el" href="group__audio.html#gac872c4749acb1685ebeabc1f9d02c0bf" title="Complete writing to an internal buffer.">audio_write_end()</a> to notify the library that the buffer is ready to be sent to AI.</p>
<dl class="section note"><dt>Note</dt><dd>This function will block until there is room to write an audio sample. If you do not want to block, check to see if there is room by calling <a class="el" href="group__audio.html#ga762b8b0c8957798c66ee158ce513e05e" title="Return whether there is an empty buffer to write to.">audio_can_write</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the internal memory buffer where to write samples. </dd></dl>

</div>
</div>
<a id="gac872c4749acb1685ebeabc1f9d02c0bf" name="gac872c4749acb1685ebeabc1f9d02c0bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac872c4749acb1685ebeabc1f9d02c0bf">&#9670;&nbsp;</a></span>audio_write_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void audio_write_end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Complete writing to an internal buffer. </p>
<p >This function is meant to be used in pair with <a class="el" href="group__audio.html#ga8aee840f13aa6903fef4c092d0ffa704" title="Start writing to the first free internal buffer.">audio_write_begin()</a>. Call this once you have generated the samples, so that the audio system knows the buffer has been filled and can be played back. </p>

</div>
</div>
<a id="gad0c6a38d6ce470872e4016ecc6d9abd3" name="gad0c6a38d6ce470872e4016ecc6d9abd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0c6a38d6ce470872e4016ecc6d9abd3">&#9670;&nbsp;</a></span>audio_write_silence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void audio_write_silence </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a chunk of silence. </p>
<p >This function will write silence to be played back by the audio system. It writes exactly <a class="el" href="group__audio.html#ga12decba34a007365bf749874e044b88d" title="Get the number of stereo samples that fit into an allocated buffer.">audio_get_buffer_length</a> stereo samples.</p>
<dl class="section note"><dt>Note</dt><dd>This function will block until there is room to write an audio sample. If you do not want to block, check to see if there is room by calling <a class="el" href="group__audio.html#ga762b8b0c8957798c66ee158ce513e05e" title="Return whether there is an empty buffer to write to.">audio_can_write</a>. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jul 7 2022 08:55:10 for libdragon by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
