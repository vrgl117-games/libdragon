<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libdragon: samplebuffer.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">libdragon
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">samplebuffer.h File Reference<div class="ingroups"><a class="el" href="group__libdragon.html">libdragon</a> &raquo; <a class="el" href="group__audio.html">Audio Subsystem</a> &raquo; <a class="el" href="group__mixer.html">Audio mixer</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Sample buffer.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
</div>
<p><a href="samplebuffer_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structsamplebuffer__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="samplebuffer_8h.html#structsamplebuffer__t">samplebuffer_t</a></td></tr>
<tr class="separator:structsamplebuffer__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a31279a3669c49567f9a00608cf37fd7f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="samplebuffer_8h.html#a31279a3669c49567f9a00608cf37fd7f">SAMPLES_BPS_SHIFT</a>(buf)&#160;&#160;&#160;((buf)-&gt;ptr_and_flags &amp; 3)</td></tr>
<tr class="separator:a31279a3669c49567f9a00608cf37fd7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b5bbcbef2291aa1528e5846a867394b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="samplebuffer_8h.html#a6b5bbcbef2291aa1528e5846a867394b">SAMPLES_PTR</a>(buf)&#160;&#160;&#160;(void*)((buf)-&gt;ptr_and_flags ^ <a class="el" href="samplebuffer_8h.html#a31279a3669c49567f9a00608cf37fd7f">SAMPLES_BPS_SHIFT</a>(buf))</td></tr>
<tr class="separator:a6b5bbcbef2291aa1528e5846a867394b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d53989292b861ff3e246c550fc9be31"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="samplebuffer_8h.html#a1d53989292b861ff3e246c550fc9be31">SAMPLES_PTR_MAKE</a>(ptr,  bps)&#160;&#160;&#160;((<a class="el" href="samplebuffer_8h.html#aef020c0b192c534ea79e1f94c8c7228f">sample_ptr_t</a>)(ptr) | (bps))</td></tr>
<tr class="separator:a1d53989292b861ff3e246c550fc9be31"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aef020c0b192c534ea79e1f94c8c7228f"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="samplebuffer_8h.html#aef020c0b192c534ea79e1f94c8c7228f">sample_ptr_t</a></td></tr>
<tr class="separator:aef020c0b192c534ea79e1f94c8c7228f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:adf77cdfe9be45e76b4065900733186f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="samplebuffer_8h.html#adf77cdfe9be45e76b4065900733186f2">samplebuffer_init</a> (<a class="el" href="samplebuffer_8h.html#structsamplebuffer__t">samplebuffer_t</a> *buf, uint8_t *uncached_mem, int size)</td></tr>
<tr class="separator:adf77cdfe9be45e76b4065900733186f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab36c29dc062a982b02d90c8515121b9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="samplebuffer_8h.html#ab36c29dc062a982b02d90c8515121b9a">samplebuffer_set_bps</a> (<a class="el" href="samplebuffer_8h.html#structsamplebuffer__t">samplebuffer_t</a> *buf, int bps)</td></tr>
<tr class="memdesc:ab36c29dc062a982b02d90c8515121b9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the bit width of the samples stored in the buffer.  <a href="samplebuffer_8h.html#ab36c29dc062a982b02d90c8515121b9a">More...</a><br /></td></tr>
<tr class="separator:ab36c29dc062a982b02d90c8515121b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1ed7b8b55c07c6c6a4c6471e94e6145"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="samplebuffer_8h.html#ae1ed7b8b55c07c6c6a4c6471e94e6145">samplebuffer_set_waveform</a> (<a class="el" href="samplebuffer_8h.html#structsamplebuffer__t">samplebuffer_t</a> *buf, <a class="el" href="mixer_8h.html#ab0e995bf04880a3e14f689f48fdb2475">WaveformRead</a> <a class="el" href="group__system.html#gaa0c5d610f8b61891a7cf5fca2671b6f9">read</a>, void *ctx)</td></tr>
<tr class="separator:ae1ed7b8b55c07c6c6a4c6471e94e6145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b810c10cdb970e8bebbfddce80fdea1"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="samplebuffer_8h.html#a7b810c10cdb970e8bebbfddce80fdea1">samplebuffer_get</a> (<a class="el" href="samplebuffer_8h.html#structsamplebuffer__t">samplebuffer_t</a> *buf, int wpos, int *wlen)</td></tr>
<tr class="memdesc:a7b810c10cdb970e8bebbfddce80fdea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to specific set of samples in the buffer (zero-copy).  <a href="samplebuffer_8h.html#a7b810c10cdb970e8bebbfddce80fdea1">More...</a><br /></td></tr>
<tr class="separator:a7b810c10cdb970e8bebbfddce80fdea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a392b4b826167c5157e983a18493cd4b5"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="samplebuffer_8h.html#a392b4b826167c5157e983a18493cd4b5">samplebuffer_append</a> (<a class="el" href="samplebuffer_8h.html#structsamplebuffer__t">samplebuffer_t</a> *buf, int wlen)</td></tr>
<tr class="memdesc:a392b4b826167c5157e983a18493cd4b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append samples into the buffer (zero-copy).  <a href="samplebuffer_8h.html#a392b4b826167c5157e983a18493cd4b5">More...</a><br /></td></tr>
<tr class="separator:a392b4b826167c5157e983a18493cd4b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af577070f844a4ab787911a647bf51f22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="samplebuffer_8h.html#af577070f844a4ab787911a647bf51f22">samplebuffer_discard</a> (<a class="el" href="samplebuffer_8h.html#structsamplebuffer__t">samplebuffer_t</a> *buf, int wpos)</td></tr>
<tr class="separator:af577070f844a4ab787911a647bf51f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3fe6abffc750a427326ed2490a64067"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="samplebuffer_8h.html#ae3fe6abffc750a427326ed2490a64067">samplebuffer_flush</a> (<a class="el" href="samplebuffer_8h.html#structsamplebuffer__t">samplebuffer_t</a> *buf)</td></tr>
<tr class="separator:ae3fe6abffc750a427326ed2490a64067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4648f973933db48c4aa1c3252333e8c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="samplebuffer_8h.html#a4648f973933db48c4aa1c3252333e8c7">samplebuffer_close</a> (<a class="el" href="samplebuffer_8h.html#structsamplebuffer__t">samplebuffer_t</a> *buf)</td></tr>
<tr class="separator:a4648f973933db48c4aa1c3252333e8c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Sample buffer. </p>
</div><hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structsamplebuffer__t" id="structsamplebuffer__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structsamplebuffer__t">&#9670;&nbsp;</a></span>samplebuffer_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct samplebuffer_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p ><a class="el" href="samplebuffer_8h.html#structsamplebuffer__t">samplebuffer_t</a> is a circular buffer of samples. It is used by the mixer to store and cache the samples required for playback on each channel. The mixer creates a sample buffer for each initialized channel. The size of the buffers is calculated for optimal playback, and might grow depending on channel usage (what waveforms are played on each channel).</p>
<p >The mixer follows a "pull" architecture. During mixer_poll, it will call <a class="el" href="samplebuffer_8c.html#a7b810c10cdb970e8bebbfddce80fdea1" title="Get a pointer to specific set of samples in the buffer (zero-copy).">samplebuffer_get()</a> to extract samples from the buffer. If the required samples are not available, the sample buffer will callback the waveform decoder to produce more samples, through the WaveformRead API. The waveform read function will push samples into the buffer via samplebuffer_append, so that they become available for the mixer. The decoder can be configured with samplebuffer_set_decoder.</p>
<p >The current implementation of samplebuffer does not achieve full zero copy, because when the buffer is full, it is flushed and samples that need to be preserved (that is, already in the buffer but not yet played back) are copied back at the beginning of the buffer with the CPU. This limitation exists because the RSP ucode (rsp_audio.S) isn't currently able to "wrap around" in the sample buffer. In future, this limitation could be lifted to achieve full zero copy.</p>
<p >The sample buffer tries to always stay 8-byte aligned to simplify operations of decoders that might need to use DMA transfers (either PI DMA or RSP DMA). To guarantee this property, <a class="el" href="mixer_8h.html#ab0e995bf04880a3e14f689f48fdb2475" title="Waveform callback function invoked by the mixer to read/generate samples.">WaveformRead</a> must collaborate by decoding the requested number of samples. If WaveformRead decodes a different number of samples, the alignment might be lost. Moreover, it always guarantees that the buffer has the same 2-byte phase of the waveforms (that is, odd samples of the waveforms are stored at odd addresses in memory); this is the minimal property required by <a class="el" href="group__dma.html#ga58b544e310a21cd57fe01da65cd27693" title="Read data from a peripheral through PI DMA, waiting for completion.">dma_read</a> (libdragon's optimized PI DMA transfer for unaligned addresses).</p>
<p >In general, the sample buffer assumes that the contained data is committed to physical memory, not just CPU cache. It is responsibility of the client to flush DMA cache (via data_cache_writeback) if samples are written via CPU. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a730ac0f50ef779dfcf6af4be1ec7a1e4" name="a730ac0f50ef779dfcf6af4be1ec7a1e4"></a><a class="el" href="samplebuffer_8h.html#aef020c0b192c534ea79e1f94c8c7228f">sample_ptr_t</a></td>
<td class="fieldname">
ptr_and_flags</td>
<td class="fielddoc">
<p >Tagged pointer to the actual buffer. Lower bits contain bit-per-shift. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a81e7365185cf66c85fe8abf47aa34a4d" name="a81e7365185cf66c85fe8abf47aa34a4d"></a>int</td>
<td class="fieldname">
ridx</td>
<td class="fielddoc">
<p >Read pointer in the sample buffer (expressed as index of samples). It remembers which sample was last read. Assuming a forward streaming, it is used by the sample buffer to discard unused samples when not needed anymore. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a426c286528e201d0b4c555819a4632cd" name="a426c286528e201d0b4c555819a4632cd"></a>int</td>
<td class="fieldname">
size</td>
<td class="fielddoc">
<p >Size of the buffer (in samples). </p>
</td></tr>
<tr><td class="fieldtype">
<a id="acddf24dc95038f2a3c91119d224cb0b4" name="acddf24dc95038f2a3c91119d224cb0b4"></a>int</td>
<td class="fieldname">
widx</td>
<td class="fielddoc">
<p >Write pointer in the sample buffer (expressed as index of samples). Since sample buffers are always filled from index 0, it is also the number of samples stored in the buffer. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a73e969a4d788679d42b3abae10258ada" name="a73e969a4d788679d42b3abae10258ada"></a>int</td>
<td class="fieldname">
wpos</td>
<td class="fielddoc">
<p >Absolute position in the waveform of the first sample in the sample buffer (the sample at index 0). It keeps track of which part of the waveform this sample buffer contains. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aca1b67ad123f7e11ba0a9ba3d5aa462c" name="aca1b67ad123f7e11ba0a9ba3d5aa462c"></a>void *</td>
<td class="fieldname">
wv_ctx</td>
<td class="fielddoc">
<p >wv_ctx is the opaque pointer to pass as context to decoder functions. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a9bc76559025664618f3fcc8c3abde8e5" name="a9bc76559025664618f3fcc8c3abde8e5"></a><a class="el" href="mixer_8h.html#ab0e995bf04880a3e14f689f48fdb2475">WaveformRead</a></td>
<td class="fieldname">
wv_read</td>
<td class="fielddoc">
<p >wv_read is invoked by samplebuffer_get whenever more samples are requested by the mixer. See <a class="el" href="mixer_8h.html#ab0e995bf04880a3e14f689f48fdb2475" title="Waveform callback function invoked by the mixer to read/generate samples.">WaveformRead</a> for more information. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a31279a3669c49567f9a00608cf37fd7f" name="a31279a3669c49567f9a00608cf37fd7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31279a3669c49567f9a00608cf37fd7f">&#9670;&nbsp;</a></span>SAMPLES_BPS_SHIFT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SAMPLES_BPS_SHIFT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buf</td><td>)</td>
          <td>&#160;&#160;&#160;((buf)-&gt;ptr_and_flags &amp; 3)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >SAMPLES_BPS_SHIFT extracts the byte-per-sample information from a sample_ptr_t. Byte-per-sample is encoded as shift value, so the actual number of bits is 1 &lt;&lt; BPS. Valid shift values are 0, 1, 2 (which corresponds to 1, 2 or 4 bytes per sample). </p>

</div>
</div>
<a id="a6b5bbcbef2291aa1528e5846a867394b" name="a6b5bbcbef2291aa1528e5846a867394b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b5bbcbef2291aa1528e5846a867394b">&#9670;&nbsp;</a></span>SAMPLES_PTR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SAMPLES_PTR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buf</td><td>)</td>
          <td>&#160;&#160;&#160;(void*)((buf)-&gt;ptr_and_flags ^ <a class="el" href="samplebuffer_8h.html#a31279a3669c49567f9a00608cf37fd7f">SAMPLES_BPS_SHIFT</a>(buf))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >SAMPLES_PTR extract the raw void* to the sample array. The size of array is not encoded in the tagged pointer. Notice that it is implemented with a XOR because on MIPS it's faster than using a reverse mask. </p>

</div>
</div>
<a id="a1d53989292b861ff3e246c550fc9be31" name="a1d53989292b861ff3e246c550fc9be31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d53989292b861ff3e246c550fc9be31">&#9670;&nbsp;</a></span>SAMPLES_PTR_MAKE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SAMPLES_PTR_MAKE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bps&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((<a class="el" href="samplebuffer_8h.html#aef020c0b192c534ea79e1f94c8c7228f">sample_ptr_t</a>)(ptr) | (bps))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >SAMPLES_PTR_MAKE create a tagged pointer, given a pointer to an array of samples and a byte-per-sample value (encoded as shift value). </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="aef020c0b192c534ea79e1f94c8c7228f" name="aef020c0b192c534ea79e1f94c8c7228f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef020c0b192c534ea79e1f94c8c7228f">&#9670;&nbsp;</a></span>sample_ptr_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t <a class="el" href="samplebuffer_8h.html#aef020c0b192c534ea79e1f94c8c7228f">sample_ptr_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Tagged pointer to an array of samples. It contains both the void* sample pointer, and byte-per-sample information (encoded as shift value). </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a392b4b826167c5157e983a18493cd4b5" name="a392b4b826167c5157e983a18493cd4b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a392b4b826167c5157e983a18493cd4b5">&#9670;&nbsp;</a></span>samplebuffer_append()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * samplebuffer_append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="samplebuffer_8h.html#structsamplebuffer__t">samplebuffer_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>wlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append samples into the buffer (zero-copy). </p>
<p >"wlen" is the number of samples that the caller will append.</p>
<p >The function returns a pointer within the sample buffer where the samples should be written. The samples to be written to physical memory, not just CPU cache, and to enforce this, the function returns a pointer in the uncached segment. Most of the times, we expect samples to be generated or manipulated via RSP/DMA anyway.</p>
<p >The function is meant only to "append" samples, as in add samples that are consecutive within the waveform to the ones already stored in the sample buffer. This is necessary because <a class="el" href="samplebuffer_8h.html#structsamplebuffer__t">samplebuffer_t</a> can only store a single range of samples of the waveform; there is no way to hold two disjoint ranges.</p>
<p >For instance, if the sample buffer currently contains 50 samples starting from position 100 in the waverform, the next call to samplebuffer_append will append samples starting at 150.</p>
<p >If required, samplebuffer_append will discard older samples to make space for the new ones, through <a class="el" href="samplebuffer_8h.html#af577070f844a4ab787911a647bf51f22">samplebuffer_discard</a>. It will only discard samples that come before the "wpos" specified in the last <a class="el" href="samplebuffer_8h.html#a7b810c10cdb970e8bebbfddce80fdea1" title="Get a pointer to specific set of samples in the buffer (zero-copy).">samplebuffer_get</a> call, so to make sure that nothing required for playback is discarded. If there is not enough space in the buffer, it will assert.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Sample buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wlen</td><td>Number of samples to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the area where new samples can be written. </dd></dl>

</div>
</div>
<a id="a4648f973933db48c4aa1c3252333e8c7" name="a4648f973933db48c4aa1c3252333e8c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4648f973933db48c4aa1c3252333e8c7">&#9670;&nbsp;</a></span>samplebuffer_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void samplebuffer_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="samplebuffer_8h.html#structsamplebuffer__t">samplebuffer_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Close the sample buffer.</p>
<p >After calling close, the sample buffer must be initialized again before using it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Sample buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af577070f844a4ab787911a647bf51f22" name="af577070f844a4ab787911a647bf51f22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af577070f844a4ab787911a647bf51f22">&#9670;&nbsp;</a></span>samplebuffer_discard()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void samplebuffer_discard </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="samplebuffer_8h.html#structsamplebuffer__t">samplebuffer_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>wpos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Discard all samples from the buffer that come before a specified absolute waveform position.</p>
<p >This function can be used to discard samples that are not needed anymore in the sample buffer. "wpos" specifies the absolute position of the first sample that should be kept: all samples that come before will be discarded. This function will silently do nothing if there are no samples to discard.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Sample buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wpos</td><td>Absolute waveform position of the first sample that must be kept. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae3fe6abffc750a427326ed2490a64067" name="ae3fe6abffc750a427326ed2490a64067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3fe6abffc750a427326ed2490a64067">&#9670;&nbsp;</a></span>samplebuffer_flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void samplebuffer_flush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="samplebuffer_8h.html#structsamplebuffer__t">samplebuffer_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Flush (reset) the sample buffer to empty status, discarding all samples.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Sample buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b810c10cdb970e8bebbfddce80fdea1" name="a7b810c10cdb970e8bebbfddce80fdea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b810c10cdb970e8bebbfddce80fdea1">&#9670;&nbsp;</a></span>samplebuffer_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * samplebuffer_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="samplebuffer_8h.html#structsamplebuffer__t">samplebuffer_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>wpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>wlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to specific set of samples in the buffer (zero-copy). </p>
<p >"wpos" is the absolute waveform position of the first sample that the caller needs access to. "wlen" is the number of requested samples.</p>
<p >The function returns a pointer within the sample buffer where the samples should be read, and optionally changes "wlen" with the maximum number of samples that can be read. "wlen" is always less or equal to the requested value.</p>
<p >If the samples are available in the buffer, they will be returned immediately. Otherwise, if the samplebuffer has a sample decoder registered via samplebuffer_set_decoder, the decoder "read" function is called once to produce the samples.</p>
<p >If "wlen" is changed with a value less than "wlen", it means that not all samples were available in the buffer and it was not possible to generate more, so the caller should not loop calling this function, but rather use what was obtained and possibly pad with silence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Sample buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wpos</td><td>Absolute waveform position of the first samples to return. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">wlen</td><td>Number of samples to return. After return, it is modified with the actual number of samples that have been returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to samples. </dd></dl>

</div>
</div>
<a id="adf77cdfe9be45e76b4065900733186f2" name="adf77cdfe9be45e76b4065900733186f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf77cdfe9be45e76b4065900733186f2">&#9670;&nbsp;</a></span>samplebuffer_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void samplebuffer_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="samplebuffer_8h.html#structsamplebuffer__t">samplebuffer_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>uncached_mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Initialize the sample buffer by binding it to the specified memory buffer.</p>
<p >The sample buffer is guaranteed to be 8-bytes aligned, so the specified memory buffer must follow this constraint. Moreover, the buffer must be in the uncached segment and not loaded in any CPU cacheline. It is strongly advised to allocate the buffer via <a class="el" href="group__n64sys.html#gaf9f812fb3f12eaee7f5186b893266d3a" title="Allocate a buffer that will be accessed as uncached memory.">malloc_uncached</a>, that takes care of these constraints.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Sample buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uncached_mem</td><td>Memory buffer to use. Must be 8-byte aligned, and in the uncached segment. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of the memory buffer, in bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab36c29dc062a982b02d90c8515121b9a" name="ab36c29dc062a982b02d90c8515121b9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab36c29dc062a982b02d90c8515121b9a">&#9670;&nbsp;</a></span>samplebuffer_set_bps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void samplebuffer_set_bps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="samplebuffer_8h.html#structsamplebuffer__t">samplebuffer_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the bit width of the samples stored in the buffer. </p>
<p >Valid values for "bps" are 1, 2, or 4: 1 can be used for 8-bit mono samples, 2 for either 8-bit interleaved stereo or 16-bit mono, and 4 for 16-bit interleaved stereo.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Sample buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bps</td><td>Bytes per sample. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae1ed7b8b55c07c6c6a4c6471e94e6145" name="ae1ed7b8b55c07c6c6a4c6471e94e6145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1ed7b8b55c07c6c6a4c6471e94e6145">&#9670;&nbsp;</a></span>samplebuffer_set_waveform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void samplebuffer_set_waveform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="samplebuffer_8h.html#structsamplebuffer__t">samplebuffer_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mixer_8h.html#ab0e995bf04880a3e14f689f48fdb2475">WaveformRead</a>&#160;</td>
          <td class="paramname"><em>read</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Connect a waveform reader callback to this sample buffer. The waveform will be use to produce samples whenever they are required by the mixer as playback progresses.</p>
<p >"read" is the main decoding function, that is invoked to produce a specified number of samples. Normally, the function is invoked by <a class="el" href="samplebuffer_8h.html#a7b810c10cdb970e8bebbfddce80fdea1" title="Get a pointer to specific set of samples in the buffer (zero-copy).">samplebuffer_get</a>, whenever the mixer requests more samples. See <a class="el" href="mixer_8h.html#ab0e995bf04880a3e14f689f48fdb2475" title="Waveform callback function invoked by the mixer to read/generate samples.">WaveformRead</a> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Sample buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">read</td><td>Waveform reading function, that produces samples. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>Opaque context that will be passed to the read function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jul 7 2022 08:55:10 for libdragon by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
